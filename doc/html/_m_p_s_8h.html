<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mpsdyn: /Users/banulsm/svn_to_port/mpsdyn/mpsdyn/src/core/headers/MPS.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mpsdyn
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_aebb8dcc11953d78e620bbef0b9e2183.html">core</a></li><li class="navelem"><a class="el" href="dir_34f1288030a4b39ca43ddf83c410a23f.html">headers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">MPS.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;Indices.h&quot;</code><br />
<code>#include &quot;<a class="el" href="_site_8h_source.html">Site.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_operator_8h_source.html">Operator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_m_p_o_8h_source.html">MPO.h</a>&quot;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="_m_p_s_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_p_s.html">MPS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7c04ed340bd0f47e08f68423ae5c4969"><td class="memItemLeft" align="right" valign="top"><a id="a7c04ed340bd0f47e08f68423ae5c4969" name="a7c04ed340bd0f47e08f68423ae5c4969"></a>
typedef <a class="el" href="class_site.html">Site</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Site_t</b></td></tr>
<tr class="separator:a7c04ed340bd0f47e08f68423ae5c4969"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0f1c1878daebfa1f78e3622712e759c0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_s_8h.html#a0f1c1878daebfa1f78e3622712e759c0">ProductState</a> { <br />
&#160;&#160;<b>p_zero</b> =zero
, <b>p_one</b>
, <b>p_xplus</b>
, <b>p_xminus</b>
, <br />
&#160;&#160;<b>p_yplus</b>
, <b>p_yminus</b>
, <b>p_special</b>
, <b>p_maxent</b>
<br />
 }</td></tr>
<tr class="separator:a0f1c1878daebfa1f78e3622712e759c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccc807f28b53fa79bda9565f123c503"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_s_8h.html#a2ccc807f28b53fa79bda9565f123c503">Gauge</a> { <b>gNone</b>
, <b>gLeft</b>
, <b>gRight</b>
, <b>gBoth</b>
 }</td></tr>
<tr class="separator:a2ccc807f28b53fa79bda9565f123c503"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afe61a0b6f9b41a5fa5e45b7690a2c9c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_s_8h.html#afe61a0b6f9b41a5fa5e45b7690a2c9c8">expandVec</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;mps, <a class="el" href="classmw_array.html">mwArray</a> &amp;vec)</td></tr>
<tr class="separator:afe61a0b6f9b41a5fa5e45b7690a2c9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05fb0217d750c4113adb864b888bd0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_s_8h.html#ae05fb0217d750c4113adb864b888bd0e">vecToMPS</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;vec, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;dims, <a class="el" href="class_m_p_s.html">MPS</a> &amp;mps, int D)</td></tr>
<tr class="separator:ae05fb0217d750c4113adb864b888bd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb14fef9f2e0e46669953c478e1af7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_s_8h.html#aeeb14fef9f2e0e46669953c478e1af7f">MPSfromMPO</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;mpo, <a class="el" href="class_m_p_s.html">MPS</a> &amp;mps, bool up=true)</td></tr>
<tr class="separator:aeeb14fef9f2e0e46669953c478e1af7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f259769a494b474dcfc6df20d7a11da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_s_8h.html#a6f259769a494b474dcfc6df20d7a11da">MPOfromMPS</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;mps, <a class="el" href="class_m_p_o.html">MPO</a> &amp;mpo, bool up=true, bool conj=false)</td></tr>
<tr class="separator:a6f259769a494b474dcfc6df20d7a11da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73da78be343a986145b44e842b9de3f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_s_8h.html#a73da78be343a986145b44e842b9de3f1">doubleMPO</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;simpleMPO, <a class="el" href="class_m_p_o.html">MPO</a> &amp;doubleMPO, bool conjugate=false)</td></tr>
<tr class="separator:a73da78be343a986145b44e842b9de3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade68023a633531bac676e097f70725df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_s_8h.html#ade68023a633531bac676e097f70725df">extendMPO</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;simpleMPO, <a class="el" href="class_m_p_o.html">MPO</a> &amp;<a class="el" href="_m_p_s_8h.html#a73da78be343a986145b44e842b9de3f1">doubleMPO</a>, int dimA)</td></tr>
<tr class="separator:ade68023a633531bac676e097f70725df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9396cf962846e72f7cdae9e4c323da94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_s_8h.html#a9396cf962846e72f7cdae9e4c323da94">extendTransposeMPO</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;simpleMPO, <a class="el" href="class_m_p_o.html">MPO</a> &amp;<a class="el" href="_m_p_s_8h.html#a73da78be343a986145b44e842b9de3f1">doubleMPO</a>, int dimA)</td></tr>
<tr class="separator:a9396cf962846e72f7cdae9e4c323da94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c90b19f80c61295b0321e041207da6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_m_p_s_8h.html#a62c90b19f80c61295b0321e041207da6">diagonalMPOfromMPS</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;mps, <a class="el" href="class_m_p_o.html">MPO</a> &amp;mpo, bool conj)</td></tr>
<tr class="separator:a62c90b19f80c61295b0321e041207da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Basic class containing an <a class="el" href="class_m_p_s.html">MPS</a></p>
<dl class="section author"><dt>Author</dt><dd>Mari-Carmen Banuls </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/03/2011 </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2ccc807f28b53fa79bda9565f123c503" name="a2ccc807f28b53fa79bda9565f123c503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccc807f28b53fa79bda9565f123c503">&#9670;&nbsp;</a></span>Gauge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_m_p_s_8h.html#a2ccc807f28b53fa79bda9565f123c503">Gauge</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >List of gauge conditions an <a class="el" href="class_m_p_s.html">MPS</a> can satisfy. This is to keep track of a previously appplied gauge condition, in case it saves us some time. It is immediately lost by replacing a site by hand, or applying an individual gauge condition to a certain site. </p>

</div>
</div>
<a id="a0f1c1878daebfa1f78e3622712e759c0" name="a0f1c1878daebfa1f78e3622712e759c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1c1878daebfa1f78e3622712e759c0">&#9670;&nbsp;</a></span>ProductState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_m_p_s_8h.html#a0f1c1878daebfa1f78e3622712e759c0">ProductState</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >List of product states that I can construct </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a62c90b19f80c61295b0321e041207da6" name="a62c90b19f80c61295b0321e041207da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c90b19f80c61295b0321e041207da6">&#9670;&nbsp;</a></span>diagonalMPOfromMPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diagonalMPOfromMPS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>mps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>mpo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Froma a <a class="el" href="class_m_p_s.html">MPS</a>, write a <a class="el" href="class_m_p_o.html">MPO</a> corresponding to an operator with the <a class="el" href="class_m_p_s.html">MPS</a> components on the diagonal. This is done by unfolding the physical index with a 3-legged delta. </p>

</div>
</div>
<a id="a73da78be343a986145b44e842b9de3f1" name="a73da78be343a986145b44e842b9de3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73da78be343a986145b44e842b9de3f1">&#9670;&nbsp;</a></span>doubleMPO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void doubleMPO </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>mpo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>doubleMPO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjoint</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >doubleMPO taxes a normal <a class="el" href="class_m_p_o.html">MPO</a>, acting on (system) physical dimensions, and constructs a double version, as in the evolution of a thermal state, for instance, where a second (transposed) copy of the <a class="el" href="class_m_p_o.html">MPO</a> acts on the (ancillary) double indices. Namely, this is the operation of folding: <br  />
 <a class="el" href="class_m_p_o.html">MPO</a> (.) <a class="el" href="class_m_p_o.html">MPO</a> -&gt; <a class="el" href="class_m_p_o.html">MPO</a> x MPO^T If conjugate==true, the operation folds <a class="el" href="class_m_p_o.html">MPO</a> (.) MPO^{dagger} -&gt; <a class="el" href="class_m_p_o.html">MPO</a> x conj(MPO) <br  />
</p>
<p >Given a regular <a class="el" href="class_m_p_o.html">MPO</a> as it would act on a vector, construct the double <a class="el" href="class_m_p_o.html">MPO</a> that will act on both sides of the linearized rho (typically a projector). If adjoint==true (default false), the <a class="el" href="class_m_p_o.html">MPO</a> acting on the right is the Hermitian conjugate. </p>

</div>
</div>
<a id="afe61a0b6f9b41a5fa5e45b7690a2c9c8" name="afe61a0b6f9b41a5fa5e45b7690a2c9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe61a0b6f9b41a5fa5e45b7690a2c9c8">&#9670;&nbsp;</a></span>expandVec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void expandVec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>mps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function which, given a <a class="el" href="class_m_p_s.html">MPS</a> (the product of physical dimensions should be smaller than 2^20, or it will crash) computes the full vector in a d^L space, with indices ordered d0,d1,d2... </p>

</div>
</div>
<a id="ade68023a633531bac676e097f70725df" name="ade68023a633531bac676e097f70725df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade68023a633531bac676e097f70725df">&#9670;&nbsp;</a></span>extendMPO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extendMPO </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>simpleMPO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>doubleMPO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >extendMPO takes a normal <a class="el" href="class_m_p_o.html">MPO</a>, and transforms it into an <a class="el" href="class_m_p_o.html">MPO</a> acting on a mixed state only on one side (the system indices). On the rest of the double index (whose dimension must be given in dimA, but is typically the same as for the physical) only the identity acts. </p>

</div>
</div>
<a id="a9396cf962846e72f7cdae9e4c323da94" name="a9396cf962846e72f7cdae9e4c323da94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9396cf962846e72f7cdae9e4c323da94">&#9670;&nbsp;</a></span>extendTransposeMPO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extendTransposeMPO </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>simpleMPO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>doubleMPO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Analogous to the one above, but puts the transposed <a class="el" href="class_m_p_o.html">MPO</a> onto the ancillary indices</p>
<p >Analogous to the one ebove, but puts the transposed <a class="el" href="class_m_p_o.html">MPO</a> onto the ancillary indices </p>

</div>
</div>
<a id="a6f259769a494b474dcfc6df20d7a11da" name="a6f259769a494b474dcfc6df20d7a11da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f259769a494b474dcfc6df20d7a11da">&#9670;&nbsp;</a></span>MPOfromMPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPOfromMPS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>mps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>mpo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>up</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conj</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reverse operation. If conj=true, the tensors are complex conjugated. </p>

</div>
</div>
<a id="aeeb14fef9f2e0e46669953c478e1af7f" name="aeeb14fef9f2e0e46669953c478e1af7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb14fef9f2e0e46669953c478e1af7f">&#9670;&nbsp;</a></span>MPSfromMPO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPSfromMPO </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>mpo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>mps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>up</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility functions that allow the manipulations of <a class="el" href="class_m_p_o.html">MPO</a> into <a class="el" href="class_m_p_s.html">MPS</a>, and viceversa, and the composition of <a class="el" href="class_m_p_o.html">MPO</a> as acting on vectorized mixed states, where the physical indices are doubled. Vectorize an <a class="el" href="class_m_p_o.html">MPO</a> to make an <a class="el" href="class_m_p_s.html">MPS</a> out of it. If up==true (default) the first component of the double physical index will be the one which was going up.</p>
<p >Vectorize an <a class="el" href="class_m_p_o.html">MPO</a> to make an <a class="el" href="class_m_p_s.html">MPS</a> out of it. If up==true (default) the first component of the double physical index will be the one which was going up.</p>
<p >mutualInfoSingleChain starts or continues the evolution using for the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> the random parameters contained in the <a class="el" href="classmw_array.html">mwArray</a> file provided as argument. It thus simulates the time evolution of an <a class="el" href="class_m_p_o.html">MPO</a> under a disordered Heisenberg <a class="el" href="class_hamiltonian.html">Hamiltonian</a> &lt;HeisenbergHamiltonian&gt;. A number of sites in the center of the chain are initially in a well defined product state (|0&gt; or|0+1&gt;) tensored with identities on both sides. The program simulates the evolution and computes the 2-Renyi entropies of different parts of the chain, to determine the mutual information. To keep track of how good the evolution is, I will also compute the energy along the way.</p>
<p >Receives arguments: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;L&gt;</td><td>(int) number of sites </td></tr>
    <tr><td class="paramname">&lt;L0&gt;</td><td>(int) number of sites (in the original chain) </td></tr>
    <tr><td class="paramname">&lt;isXY&gt;</td><td>(bool) whether the model to be considered is only XY (no ZZ term) </td></tr>
    <tr><td class="paramname">&lt;J&gt;</td><td>(double) parameter <img class="formulaInl" alt="$J$" src="form_89.png"/> of the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> (Jx=Jy=Jz or Jx=Jy) </td></tr>
    <tr><td class="paramname">&lt;h&gt;</td><td>(double) parameter <img class="formulaInl" alt="$h$" src="form_91.png"/> of the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> (local values randomly distributed between -h and h) <br  />
 </td></tr>
    <tr><td class="paramname">&lt;isCont&gt;</td><td>(bool) whether the model to be considered has continuous randomness </td></tr>
    <tr><td class="paramname">&lt;paramFile&gt;</td><td>(char*) file with the coefficients for the magnetic field </td></tr>
    <tr><td class="paramname">&lt;nrInst&gt;</td><td>(int) Nr of row in the file to be used (if rows are longer than L, the first L values of the row will be used). </td></tr>
    <tr><td class="paramname">&lt;init&gt;</td><td>(char) initial pure state in the middle L0 sites, can be 1 (X+), 2(Y+) or 3 (Z+) </td></tr>
    <tr><td class="paramname">&lt;delta&gt;</td><td>(double) width of the time step used </td></tr>
    <tr><td class="paramname">&lt;M&gt;</td><td>(int) number of steps </td></tr>
    <tr><td class="paramname">&lt;rate&gt;</td><td>(int) frequency of recording data (nr of steps) Results will be saved for 0,rate,2*rate...,M </td></tr>
    <tr><td class="paramname">&lt;D&gt;</td><td>(int) maximum bond dimension </td></tr>
    <tr><td class="paramname">&lt;outfname&gt;</td><td>(char*) name of the output file for the results (will be appended if newInstance is 0 and it exists) </td></tr>
    <tr><td class="paramname">&lt;mpsfile&gt;</td><td>(char*) name of the file where to read/save the final <a class="el" href="class_m_p_s.html">MPS</a> </td></tr>
    <tr><td class="paramname">&lt;newInstance&gt;</td><td>(bool) whether to start a new evolution from the inhomogeneous polarization distribution (if not, the <a class="el" href="class_m_p_s.html">MPS</a> in mpsfile is used) </td></tr>
    <tr><td class="paramname">&lt;M0&gt;</td><td>(int) OPTIONAL, only read if newInstance is false, it is the number of steps already done in the existing file. Construct the initial state and observable, but vectorized Vectorize an <a class="el" href="class_m_p_o.html">MPO</a> to make an <a class="el" href="class_m_p_s.html">MPS</a> out of it. If up==true (default) the first component of the double physical index will be the one which was going up.</td></tr>
  </table>
  </dd>
</dl>
<p>qubitSingleChain starts or continues the evolution using for the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> the random parameters contained in the <a class="el" href="classmw_array.html">mwArray</a> file provided as argument. It thus simulates the time evolution of an <a class="el" href="class_m_p_o.html">MPO</a> under a disordered Heisenberg <a class="el" href="class_hamiltonian.html">Hamiltonian</a> &lt;HeisenbergHamiltonian&gt;. A number of sites in the center of the chain are used to encode a single qubit, so that <img class="formulaInl" alt="$| \tilde{0} \rangle \langle \tilde{0}|$" src="form_105.png"/> corresponds to <img class="formulaInl" alt="$\left ( | 0 \rangle \langle 0| \right )^{\otimes L_0}$" src="form_106.png"/> tensored with identities on both sides. Starting from an <a class="el" href="class_m_p_o.html">MPO</a> which encodes the <img class="formulaInl" alt="$sigma_{x(y,z)}$" src="form_107.png"/>, the program simulates the evolution and computes the trace norm of the resulting state when tracing out the edges, and keeping <img class="formulaInl" alt="$L_0,L0+2,\ldots 10$" src="form_108.png"/> spins. This will allow us to compute the recovery fidelity. computes the average and localized magnetization along the way. To keep track of how good the evolution is, I will also compute the energy along the way.</p>
<p >Receives arguments: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;L&gt;</td><td>(int) number of sites </td></tr>
    <tr><td class="paramname">&lt;L0&gt;</td><td>(int) number of sites (in the original chain) </td></tr>
    <tr><td class="paramname">&lt;isXY&gt;</td><td>(bool) whether the model to be considered is only XY (no ZZ term) </td></tr>
    <tr><td class="paramname">&lt;J&gt;</td><td>(double) parameter <img class="formulaInl" alt="$J$" src="form_89.png"/> of the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> (Jx=Jy=Jz or Jx=Jy) </td></tr>
    <tr><td class="paramname">&lt;h&gt;</td><td>(double) parameter <img class="formulaInl" alt="$h$" src="form_91.png"/> of the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> (local values randomly distributed between -h and h) <br  />
 </td></tr>
    <tr><td class="paramname">&lt;isCont&gt;</td><td>(bool) whether the model to be considered has continuous randomness </td></tr>
    <tr><td class="paramname">&lt;paramFile&gt;</td><td>(char*) file with the coefficients for the magnetic field </td></tr>
    <tr><td class="paramname">&lt;nrInst&gt;</td><td>(int) Nr of row in the file to be used (if rows are longer than L, the first L values of the row will be used). </td></tr>
    <tr><td class="paramname">&lt;init&gt;</td><td>(char) initial state in the middle, can be 1 (<a class="el" href="class_x.html">X</a>), 2(Y) or 3 (Z) </td></tr>
    <tr><td class="paramname">&lt;delta&gt;</td><td>(double) width of the time step used </td></tr>
    <tr><td class="paramname">&lt;M&gt;</td><td>(int) number of steps </td></tr>
    <tr><td class="paramname">&lt;rate&gt;</td><td>(int) frequency of recording data (nr of steps) Results will be saved for 0,rate,2*rate...,M </td></tr>
    <tr><td class="paramname">&lt;D&gt;</td><td>(int) maximum bond dimension </td></tr>
    <tr><td class="paramname">&lt;outfname&gt;</td><td>(char*) name of the output file for the results (will be appended if newInstance is 0 and it exists) </td></tr>
    <tr><td class="paramname">&lt;mpsfile&gt;</td><td>(char*) name of the file where to read/save the <a class="el" href="class_m_p_s.html">MPS</a> </td></tr>
    <tr><td class="paramname">&lt;jobsdir&gt;</td><td>(char*) name of the dir to write the new jobs </td></tr>
    <tr><td class="paramname">&lt;outfname_traces&gt;</td><td>(char*) name of the output file for the trace norms results </td></tr>
    <tr><td class="paramname">&lt;normFreq&gt;</td><td>(int) frequency (steps) to compute and write trace norms of reduced states. If it is 0, non will be computed. </td></tr>
    <tr><td class="paramname">&lt;newInstance&gt;</td><td>(bool) whether to start a new evolution from the inhomogeneous polarization distribution (if not, the <a class="el" href="class_m_p_s.html">MPS</a> in mpsfile is used) </td></tr>
    <tr><td class="paramname">&lt;M0&gt;</td><td>(int) OPTIONAL, only read if newInstance is false, it is the number of steps already done in the existing file. Construct the initial state and observable, but vectorized Vectorize an <a class="el" href="class_m_p_o.html">MPO</a> to make an <a class="el" href="class_m_p_s.html">MPS</a> out of it. If up==true (default) the first component of the double physical index will be the one which was going up.</td></tr>
  </table>
  </dd>
</dl>
<p>Based on qubitSingleChain and mutualInfoSingleChain, this program starts or continues the evolution using for the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> the random parameters contained in the <a class="el" href="classmw_array.html">mwArray</a> file provided as argument. It thus simulates the time evolution of an <a class="el" href="class_m_p_o.html">MPO</a> under a disordered Heisenberg <a class="el" href="class_hamiltonian.html">Hamiltonian</a> &lt;HeisenbergHamiltonian&gt;. A number of sites in the center of the chain are used to encode a single qubit, so that <img class="formulaInl" alt="$| \tilde{0} \rangle \langle \tilde{0}|$" src="form_105.png"/> corresponds to <img class="formulaInl" alt="$\left ( | 0 \rangle \langle 0| \right )^{\otimes L_0}$" src="form_106.png"/> tensored with identities on both sides. Starting from an <a class="el" href="class_m_p_o.html">MPO</a> which encodes a pure state, Z+, Z-, X+ or X-, the program simulates the evolution and computes the trace norm of the resulting simga_Z or sigma_X evolved state when tracing out the edges, and keeping <img class="formulaInl" alt="$L_0,L0+2,\ldots 10$" src="form_108.png"/> spins. This will allow us to compute the recovery fidelity.</p>
<p >To be able to control the error in the trace, instead of evolving the sigmas, I evolve two pure states and correct the trace oe each after every step so that it is one. Then I compute the trace norm of the difference between the reduced density matrix for states + and -.</p>
<p >Additionally, we compute the (2-Renyi) mutual information for the central spins (from L0 to N-2) wrt the rest and across all cuts of the chain. The program can compute the average and localized magnetization along the way. To keep track of how good the evolution is, I will also compute the energy along the way.</p>
<p >Receives arguments as <a class="el" href="class_properties.html">Properties</a> file, as config/rfmi.conf, containing the required parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;L&gt;</td><td>(int) number of sites </td></tr>
    <tr><td class="paramname">&lt;L0&gt;</td><td>(int) number of sites (in the original chain) </td></tr>
    <tr><td class="paramname">&lt;isXY&gt;</td><td>(bool) whether the model to be considered is only XY (no ZZ term) </td></tr>
    <tr><td class="paramname">&lt;J&gt;</td><td>(double) parameter <img class="formulaInl" alt="$J$" src="form_89.png"/> of the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> (Jx=Jy=Jz or Jx=Jy) </td></tr>
    <tr><td class="paramname">&lt;h&gt;</td><td>(double) parameter <img class="formulaInl" alt="$h$" src="form_91.png"/> of the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> (local values randomly distributed between -h and h) <br  />
 </td></tr>
    <tr><td class="paramname">&lt;isCont&gt;</td><td>(bool) whether the model to be considered has continuous randomness </td></tr>
    <tr><td class="paramname">&lt;paramFile&gt;</td><td>(char*) file with the coefficients for the magnetic field </td></tr>
    <tr><td class="paramname">&lt;nrInst&gt;</td><td>(int) Nr of row in the file to be used (if rows are longer than L, the first L values of the row will be used). </td></tr>
    <tr><td class="paramname">&lt;init&gt;</td><td>(char) initial state in the middle, can be 1 (<a class="el" href="class_x.html">X</a>), or 3 (Z) (" for Y is equivalent to X)
@param &lt;delta&gt; (double) width of the time step used
@param &lt;M&gt; (int) number of steps
@param &lt;rate&gt; (int) frequency of recording data (nr of steps)
                   Results will be saved for 0,rate,2*rate...,M
@param &lt;D&gt; (int) maximum bond dimension
@param &lt;outfname&gt; (char*) name of the output file for the results
               (will be appended if newInstance is 0 and it exists)
@param &lt;mpsdir&gt; (char*) name of the dir where to read/save the MPS files (tmp and final)
@param &lt;mpsfileP&gt; (char*) name of the file where to read/save the MPS for + state
@param &lt;mpsfileM&gt; (char*) name of the file where to read/save the MPS for - state
@param &lt;outfname_traces&gt; (char*) name of the output file for the trace norms results
@param &lt;savingFreq&gt; (int) frequency (steps) to save the tmp MPS file
@param &lt;newInstance&gt; (bool) whether to start a new evolution from
                     the inhomogeneous polarization distribution
         (if not, the MPS in mpsfile is used)

To be able to resume evolution after an interruption
(e.g. exhausted time) I will save a temporary file with the same
name as mpsfile, but a suffix indicating the latest advance. Every
certain number of steps (normFreq), the temporary file is saved
with the current count, and the previous one is removed. when the
evolution starts, if newInstance is set to 0, the directory is
checked for the existence of such file.
Vectorize an MPO to make an MPS out of it. If up==true (default)
the first component of the double physical index will be the one
which was going up.

Based on qubitSingleChain and mutualInfoSingleChain, this program 
starts or continues the evolution using for the
Hamiltonian the random parameters contained in the mwArray file
provided as argument.
It thus simulates the time evolution of an MPO under a
disordered Heisenberg Hamiltonian \ref &lt;HeisenbergHamiltonian&gt;.
A number of sites in the center of the chain are used to encode a single qubit, so that 
 \_form#105 corresponds to 
 \_form#106
tensored with identities on both sides.
Starting from an MPO which encodes a pure state, Z+, Z-, X+ or X-,
the program simulates the evolution and computes the trace norm of the resulting 
simga_Z or sigma_X evolved state when tracing out the edges, and keeping \_form#108
spins. This will allow us to compute the recovery fidelity.

To be able to control the error in the trace, instead of evolving
the sigmas, I evolve two pure states and correct the trace oe each
after every step so that it is one. Then I compute the trace norm
of the difference between the reduced density matrix for states +
and -.

Additionally, we compute the (2-Renyi) mutual information for the
central spins (from L0 to N-2) wrt the rest and across all cuts of
the chain. The program can compute the average and localized
magnetization along the way.  To keep track of how good the
evolution is, I will also compute the energy along the way.


Receives arguments as Properties file, as config/rfmi.conf, 
containing the required parameters 
@param &lt;L&gt; (int) number of sites
@param &lt;L0&gt; (int) number of sites (in the original chain)
@param &lt;isXY&gt; (bool) whether the model to be considered is only XY (no ZZ term) 
@param &lt;J&gt; (double) parameter \_form#89 of the Hamiltonian (Jx=Jy=Jz or Jx=Jy)
@param &lt;h&gt; (double) parameter \_form#91 of the Hamiltonian (local values 
                    randomly distributed between -h and h)          &lt;br&gt;
@param &lt;isCont&gt; (bool) whether the model to be considered has continuous randomness
@param &lt;paramFile&gt; (char*) file with the coefficients for the magnetic field
@param &lt;nrInst&gt; (int) Nr of row in the file to be used (if rows
                   are longer than L, the first L values of the row will be used).
@param &lt;init&gt; (char) initial state in the middle, can be 1 (X),
                    or 3 (Z) (" for Y is equivalent to <a class="el" href="class_x.html">X</a>) </td></tr>
    <tr><td class="paramname">&lt;delta&gt;</td><td>(double) width of the time step used </td></tr>
    <tr><td class="paramname">&lt;M&gt;</td><td>(int) number of steps </td></tr>
    <tr><td class="paramname">&lt;rate&gt;</td><td>(int) frequency of recording data (nr of steps) Results will be saved for 0,rate,2*rate...,M </td></tr>
    <tr><td class="paramname">&lt;D&gt;</td><td>(int) maximum bond dimension </td></tr>
    <tr><td class="paramname">&lt;outfname&gt;</td><td>(char*) name of the output file for the results (will be appended if newInstance is 0 and it exists) </td></tr>
    <tr><td class="paramname">&lt;mpsdir&gt;</td><td>(char*) name of the dir where to read/save the <a class="el" href="class_m_p_s.html">MPS</a> files (tmp and final) </td></tr>
    <tr><td class="paramname">&lt;mpsfileP&gt;</td><td>(char*) name of the file where to read/save the <a class="el" href="class_m_p_s.html">MPS</a> for + state </td></tr>
    <tr><td class="paramname">&lt;mpsfileM&gt;</td><td>(char*) name of the file where to read/save the <a class="el" href="class_m_p_s.html">MPS</a> for - state </td></tr>
    <tr><td class="paramname">&lt;outfname_traces&gt;</td><td>(char*) name of the output file for the trace norms results </td></tr>
    <tr><td class="paramname">&lt;savingFreq&gt;</td><td>(int) frequency (steps) to save the tmp <a class="el" href="class_m_p_s.html">MPS</a> file </td></tr>
    <tr><td class="paramname">&lt;newInstance&gt;</td><td>(bool) whether to start a new evolution from the inhomogeneous polarization distribution (if not, the <a class="el" href="class_m_p_s.html">MPS</a> in mpsfile is used)</td></tr>
  </table>
  </dd>
</dl>
<p>To be able to resume evolution after an interruption (e.g. exhausted time) I will save a temporary file with the same name as mpsfile, but a suffix indicating the latest advance. Every certain number of steps (normFreq), the temporary file is saved with the current count, and the previous one is removed. when the evolution starts, if newInstance is set to 0, the directory is checked for the existence of such file.</p>
<p >In this version (positive) we use the trick that our starting states are <img class="formulaInl" alt="$\rho=\rho_{1/2}^{\dagger} \rho_{1/2)$" src="form_109.png"/>, where <img class="formulaInl" alt="$\rho_{1/2}=\left ( \frac{Id}{\sqrt{d}}\right )^{\otimes L-L_0}
\otimes |\phi_0\rangle \langle \phi_0| $" src="form_110.png"/> (so, basically <img class="formulaInl" alt="$\rho$" src="form_111.png"/> with different normalization, and the evolved state can be written as <img class="formulaInl" alt="$rho(t)=\rho_{1/2}(t)^{\dagger} \rho_{1/2}(t)$" src="form_112.png"/>, with <img class="formulaInl" alt="$\rho_{1/2}(t)=U(t) \rho_{1/2} U(t)^{\dagger}$" src="form_113.png"/>. In practice, this means that squaring the obtained state (and properly normalizing) we obtain a positive <a class="el" href="class_m_p_o.html">MPO</a> ansatz for the evolved state. To achieve the results with this construction, I use specific (MPO-origami) tricks. Some optimization would be needed for the expandOper step. Vectorize an <a class="el" href="class_m_p_o.html">MPO</a> to make an <a class="el" href="class_m_p_s.html">MPS</a> out of it. If up==true (default) the first component of the double physical index will be the one which was going up. If conj==true, tensors are complex conjugated </p>

</div>
</div>
<a id="ae05fb0217d750c4113adb864b888bd0e" name="ae05fb0217d750c4113adb864b888bd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05fb0217d750c4113adb864b888bd0e">&#9670;&nbsp;</a></span>vecToMPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vecToMPS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>mps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a vector vec, corresponding to a multidimensional array, with dimensions dims (if the current shape does not agree with that, a copy will be done and reshaped) transform it into a <a class="el" href="class_m_p_s.html">MPS</a> with L sites of corresponding physical dimensions dims[0],dims[1],... , and maximum bond dimension D (just by local truncation). </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
