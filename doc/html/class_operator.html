<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mpsdyn: Operator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logoMPSDYN.png"/></td>
  <td id="projectalign">
   <div id="projectname">mpsdyn
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_operator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Operator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_operator_8h_source.html">Operator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Operator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_operator.png" usemap="#Operator_map" alt=""/>
  <map id="Operator_map" name="Operator_map">
<area href="class_folded_operator.html" alt="FoldedOperator" shape="rect" coords="0,56,111,80"/>
<area href="class_joined_operator.html" alt="JoinedOperator" shape="rect" coords="121,56,232,80"/>
<area href="class_variable_operator.html" alt="VariableOperator" shape="rect" coords="242,56,353,80"/>
<area href="class_double_operator.html" alt="DoubleOperator" shape="rect" coords="0,112,111,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af4a5e2eba64cb694e4036853c367dbe3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#af4a5e2eba64cb694e4036853c367dbe3">Operator</a> (int d, int Dl, int Dr, int d2=0)</td></tr>
<tr class="separator:af4a5e2eba64cb694e4036853c367dbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab1ff2693a66c58b8ca84ad86f1c3a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#aaab1ff2693a66c58b8ca84ad86f1c3a2">Operator</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;dims)</td></tr>
<tr class="separator:aaab1ff2693a66c58b8ca84ad86f1c3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6433ac14692f26834929ef6fd1019fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#ad6433ac14692f26834929ef6fd1019fb">Operator</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;oper)</td></tr>
<tr class="separator:ad6433ac14692f26834929ef6fd1019fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f28d6a759dc0de73ef1d33402532f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a20f28d6a759dc0de73ef1d33402532f5">Operator</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;oper, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;neworder, bool conjugate=0)</td></tr>
<tr class="separator:a20f28d6a759dc0de73ef1d33402532f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e6f4ba76768e36a21bd8d0e7df2bc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a04e6f4ba76768e36a21bd8d0e7df2bc2">Operator</a> (int nr, const <a class="el" href="class_operator.html">Operator</a> *oprs[])</td></tr>
<tr class="separator:a04e6f4ba76768e36a21bd8d0e7df2bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fb2be3fc00cb24b56546e3827ab544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a97fb2be3fc00cb24b56546e3827ab544">setData</a> (const <a class="el" href="classmw_array.html">mwArray</a> *oper)</td></tr>
<tr class="separator:a97fb2be3fc00cb24b56546e3827ab544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e19ae5991bb39c2d26b77f65b2d899"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a48e19ae5991bb39c2d26b77f65b2d899">getFullData</a> () const</td></tr>
<tr class="separator:a48e19ae5991bb39c2d26b77f65b2d899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9194cd5f6477aa2947aa00c12852db39"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a9194cd5f6477aa2947aa00c12852db39">getDimensions</a> () const</td></tr>
<tr class="separator:a9194cd5f6477aa2947aa00c12852db39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73406076be97b3ab257549d1d35deb83"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a73406076be97b3ab257549d1d35deb83">conjugateOp</a> ()</td></tr>
<tr class="separator:a73406076be97b3ab257549d1d35deb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cecb803667ebf7fb9b3df5328a02f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#ae4cecb803667ebf7fb9b3df5328a02f6">contractRight</a> (const <a class="el" href="class_operator.html">Operator</a> *rightOp)</td></tr>
<tr class="separator:ae4cecb803667ebf7fb9b3df5328a02f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4bb4a88eea9356164eb19d0ae1b49a"><td class="memItemLeft" align="right" valign="top"><a id="aab4bb4a88eea9356164eb19d0ae1b49a" name="aab4bb4a88eea9356164eb19d0ae1b49a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>permuteOp</b> (<a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> perm)</td></tr>
<tr class="separator:aab4bb4a88eea9356164eb19d0ae1b49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa110d275c972eb5a8e89c301d5d5a3bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#aa110d275c972eb5a8e89c301d5d5a3bc">setRotatedData</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;oper, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;neworder, bool conjugate=0)</td></tr>
<tr class="separator:aa110d275c972eb5a8e89c301d5d5a3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d565da8d05429af29b2d2da1f7b36a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a4d565da8d05429af29b2d2da1f7b36a7">contractL</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;result, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termL, const <a class="el" href="class_site.html">Site</a> &amp;ket, const <a class="el" href="class_site.html">Site</a> &amp;bra, bool dagger=0) const</td></tr>
<tr class="separator:a4d565da8d05429af29b2d2da1f7b36a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e75934c3aa9df2c4aeb204b76f46d81"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a2e75934c3aa9df2c4aeb204b76f46d81">contractR</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;result, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termR, const <a class="el" href="class_site.html">Site</a> &amp;ket, const <a class="el" href="class_site.html">Site</a> &amp;bra, bool dagger=0) const</td></tr>
<tr class="separator:a2e75934c3aa9df2c4aeb204b76f46d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80868fb8d8af8ed6b99afe8e0c644707"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a80868fb8d8af8ed6b99afe8e0c644707">contractL2</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;result, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termL, const <a class="el" href="class_site.html">Site</a> &amp;ket, const <a class="el" href="class_site.html">Site</a> &amp;bra, bool dagger=0) const</td></tr>
<tr class="separator:a80868fb8d8af8ed6b99afe8e0c644707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb58ba7490de349794fd461b7da14269"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#afb58ba7490de349794fd461b7da14269">contractR2</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;result, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termR, const <a class="el" href="class_site.html">Site</a> &amp;ket, const <a class="el" href="class_site.html">Site</a> &amp;bra, bool dagger=0) const</td></tr>
<tr class="separator:afb58ba7490de349794fd461b7da14269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ed724a64b3d88446eaa6c2cae47d72"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a24ed724a64b3d88446eaa6c2cae47d72">contractMket</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;result, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termL, const <a class="el" href="class_site.html">Site</a> &amp;ket, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termR, bool dagger=0) const</td></tr>
<tr class="separator:a24ed724a64b3d88446eaa6c2cae47d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaeca62fcd4e390478bf5755ce868f0a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#aeaeca62fcd4e390478bf5755ce868f0a">contractMbra</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;result, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termL, const <a class="el" href="class_site.html">Site</a> &amp;bra, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termR, bool dagger=0) const</td></tr>
<tr class="separator:aeaeca62fcd4e390478bf5755ce868f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602eda0a198f5c6227ab20b48ef71d0c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a602eda0a198f5c6227ab20b48ef71d0c">contractN</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;result, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termL, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termR, bool dagger=0) const</td></tr>
<tr class="separator:a602eda0a198f5c6227ab20b48ef71d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19923e304de5013934422eb43186ab2f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a19923e304de5013934422eb43186ab2f">contractN2</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;result, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termL, const <a class="el" href="classmw_array.html">mwArray</a> &amp;termR, bool dagger=0) const</td></tr>
<tr class="separator:a19923e304de5013934422eb43186ab2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27ce9ee451111d974ef5e80f06462e0"><td class="memItemLeft" align="right" valign="top"><a id="af27ce9ee451111d974ef5e80f06462e0" name="af27ce9ee451111d974ef5e80f06462e0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getd</b> () const</td></tr>
<tr class="separator:af27ce9ee451111d974ef5e80f06462e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473ab726851e524f0fa5cc6e9ae3fc14"><td class="memItemLeft" align="right" valign="top"><a id="a473ab726851e524f0fa5cc6e9ae3fc14" name="a473ab726851e524f0fa5cc6e9ae3fc14"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDl</b> () const</td></tr>
<tr class="separator:a473ab726851e524f0fa5cc6e9ae3fc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4982cc1d744d408decfa2b923b12c773"><td class="memItemLeft" align="right" valign="top"><a id="a4982cc1d744d408decfa2b923b12c773" name="a4982cc1d744d408decfa2b923b12c773"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDr</b> () const</td></tr>
<tr class="separator:a4982cc1d744d408decfa2b923b12c773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588db8c4df53959eb4a690e38f38ac76"><td class="memItemLeft" align="right" valign="top"><a id="a588db8c4df53959eb4a690e38f38ac76" name="a588db8c4df53959eb4a690e38f38ac76"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getdorig</b> () const</td></tr>
<tr class="separator:a588db8c4df53959eb4a690e38f38ac76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d7a42ccdc9114331a743ad58eb3d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a859d7a42ccdc9114331a743ad58eb3d2">savetext</a> (std::ofstream &amp;outfile) const</td></tr>
<tr class="separator:a859d7a42ccdc9114331a743ad58eb3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39c8c5e7ca66013df10185d18112acc"><td class="memItemLeft" align="right" valign="top"><a id="ae39c8c5e7ca66013df10185d18112acc" name="ae39c8c5e7ca66013df10185d18112acc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>loadtext</b> (std::ifstream &amp;outfile)</td></tr>
<tr class="separator:ae39c8c5e7ca66013df10185d18112acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a31a00a5252514938238fbe2dfc2039"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a4a31a00a5252514938238fbe2dfc2039">put</a> (std::ostream &amp;os) const</td></tr>
<tr class="separator:a4a31a00a5252514938238fbe2dfc2039"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afabb6472bdf16d7deb115599c419adc0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_operator.html">Operator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#afabb6472bdf16d7deb115599c419adc0">identity</a> (int d)</td></tr>
<tr class="separator:afabb6472bdf16d7deb115599c419adc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a681615907a438d8874f7e4c303ce4fc7"><td class="memItemLeft" align="right" valign="top"><a id="a681615907a438d8874f7e4c303ce4fc7" name="a681615907a438d8874f7e4c303ce4fc7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Operator</b> (const <a class="el" href="class_operator.html">Operator</a> &amp;op)</td></tr>
<tr class="separator:a681615907a438d8874f7e4c303ce4fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa929abebf43feeda03fe07e4e631769b"><td class="memItemLeft" align="right" valign="top"><a id="aa929abebf43feeda03fe07e4e631769b" name="aa929abebf43feeda03fe07e4e631769b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:aa929abebf43feeda03fe07e4e631769b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3569321ea9089d856b53fc1f66c6e962"><td class="memItemLeft" align="right" valign="top"><a id="a3569321ea9089d856b53fc1f66c6e962" name="a3569321ea9089d856b53fc1f66c6e962"></a>
virtual <a class="el" href="class_operator.html">Operator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_operator.html">Operator</a> &amp;op)</td></tr>
<tr class="separator:a3569321ea9089d856b53fc1f66c6e962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd8e293ed96bea98b273789d49594aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a2cd8e293ed96bea98b273789d49594aa">Operator</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;oper, int d, int Dl, int Dr, int d2=0)</td></tr>
<tr class="separator:a2cd8e293ed96bea98b273789d49594aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba56196a9ee5d496704a19afef90f6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#a2ba56196a9ee5d496704a19afef90f6b">setData</a> (const <a class="el" href="classmw_array.html">mwArray</a> *oper, int d, int Dl, int Dr)</td></tr>
<tr class="separator:a2ba56196a9ee5d496704a19afef90f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9d31d7d2b02fa4fb4a26111417cdc1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_operator.html#aea9d31d7d2b02fa4fb4a26111417cdc1">getInnerDimension</a> (int k) const</td></tr>
<tr class="separator:aea9d31d7d2b02fa4fb4a26111417cdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0ae6e42e6da86ccb8f6971ef3234548b"><td class="memItemLeft" align="right" valign="top"><a id="a0ae6e42e6da86ccb8f6971ef3234548b" name="a0ae6e42e6da86ccb8f6971ef3234548b"></a>
<a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dims</b></td></tr>
<tr class="separator:a0ae6e42e6da86ccb8f6971ef3234548b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebb68919ba4953100a89a23fd4fc532"><td class="memItemLeft" align="right" valign="top"><a id="a2ebb68919ba4953100a89a23fd4fc532" name="a2ebb68919ba4953100a89a23fd4fc532"></a>
const <a class="el" href="classmw_array.html">mwArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:a2ebb68919ba4953100a89a23fd4fc532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8679e178e70045c5ff6319e2ec66e442"><td class="memItemLeft" align="right" valign="top"><a id="a8679e178e70045c5ff6319e2ec66e442" name="a8679e178e70045c5ff6319e2ec66e442"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mydata</b></td></tr>
<tr class="separator:a8679e178e70045c5ff6319e2ec66e442"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab701db64c2f09b09c07690a9f87fa5b9"><td class="memItemLeft" align="right" valign="top"><a id="ab701db64c2f09b09c07690a9f87fa5b9" name="ab701db64c2f09b09c07690a9f87fa5b9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MPO</b></td></tr>
<tr class="separator:ab701db64c2f09b09c07690a9f87fa5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc6bbaef591cc67e4a3477b419d706e"><td class="memItemLeft" align="right" valign="top"><a id="afdc6bbaef591cc67e4a3477b419d706e" name="afdc6bbaef591cc67e4a3477b419d706e"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="class_operator.html">Operator</a> &amp;sigma)</td></tr>
<tr class="separator:afdc6bbaef591cc67e4a3477b419d706e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A general operator (from an operator row) which can act on a given site of a <a class="el" href="class_m_p_s.html">MPS</a> chain. Particular cases may have specific ways of being contracted. Therefore this could be mainly the general interface, that should be extended appropriately. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af4a5e2eba64cb694e4036853c367dbe3" name="af4a5e2eba64cb694e4036853c367dbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a5e2eba64cb694e4036853c367dbe3">&#9670;&nbsp;</a></span>Operator() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Operator::Operator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Dr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct an empty operator of dimensions d x Dl x d2 x Dr (if d2 not specified, it is assumed to be d) </p>

</div>
</div>
<a id="aaab1ff2693a66c58b8ca84ad86f1c3a2" name="aaab1ff2693a66c58b8ca84ad86f1c3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab1ff2693a66c58b8ca84ad86f1c3a2">&#9670;&nbsp;</a></span>Operator() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Operator::Operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct an empty operator of dimensions dims </p>

</div>
</div>
<a id="ad6433ac14692f26834929ef6fd1019fb" name="ad6433ac14692f26834929ef6fd1019fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6433ac14692f26834929ef6fd1019fb">&#9670;&nbsp;</a></span>Operator() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Operator::Operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>oper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct an operator, for a given array whose dimensions should be arranged as: du*dl*dd*dr. Saves an internal copy of the data. <br  />
 </p>

</div>
</div>
<a id="a20f28d6a759dc0de73ef1d33402532f5" name="a20f28d6a759dc0de73ef1d33402532f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f28d6a759dc0de73ef1d33402532f5">&#9670;&nbsp;</a></span>Operator() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Operator::Operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>neworder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjugate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Special case: Construct an operator, from a rotated array whose dimensions should be rearranged (permuted) as neworder indicates, <br  />
 so that at the end they are du*dl*dd*dr If conjugate==1, the date is complex conjugated before saving it. </p>

</div>
</div>
<a id="a04e6f4ba76768e36a21bd8d0e7df2bc2" name="a04e6f4ba76768e36a21bd8d0e7df2bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e6f4ba76768e36a21bd8d0e7df2bc2">&#9670;&nbsp;</a></span>Operator() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Operator::Operator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_operator.html">Operator</a> *&#160;</td>
          <td class="paramname"><em>oprs</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Construct a new <a class="el" href="class_operator.html">Operator</a> from joining together a number of Operators, in the order they are passed as arguments. The last operator in the array should be the first one acting on the ket. The resulting dimensions (left and right) are the product of all the original ones. For some optimization (like remembering the structure of multiple operators and using it in the contractions) a <a class="el" href="class_joined_operator.html">JoinedOperator</a> should be used instead. </p>

</div>
</div>
<a id="a2cd8e293ed96bea98b273789d49594aa" name="a2cd8e293ed96bea98b273789d49594aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd8e293ed96bea98b273789d49594aa">&#9670;&nbsp;</a></span>Operator() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Operator::Operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Dr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct an operator, for a given array but ignore the dimensions of it and set d, Dl and Dr (d2) as specified. This is for derived classes that do not store the operator as a block, like UOperator. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a73406076be97b3ab257549d1d35deb83" name="a73406076be97b3ab257549d1d35deb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73406076be97b3ab257549d1d35deb83">&#9670;&nbsp;</a></span>conjugateOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::conjugateOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Conjugate all stored data. If the data was not mine, it is copied now, because I am not supposed to change some external array. </p>

<p>Reimplemented in <a class="el" href="class_folded_operator.html#a76bb4c2836cc68735553b8032393e769">FoldedOperator</a>, and <a class="el" href="class_joined_operator.html#aa33c7d33553c1e60f45105e453c90225">JoinedOperator</a>.</p>

</div>
</div>
<a id="a4d565da8d05429af29b2d2da1f7b36a7" name="a4d565da8d05429af29b2d2da1f7b36a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d565da8d05429af29b2d2da1f7b36a7">&#9670;&nbsp;</a></span>contractL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::contractL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_site.html">Site</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_site.html">Site</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dagger</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Contract the operator with a left term, between bra and ket, and return a new "left" term. </p>

<p>Reimplemented in <a class="el" href="class_folded_operator.html#ad03a6bee14fc887a4f6e96cd6c1d08c2">FoldedOperator</a>, and <a class="el" href="class_joined_operator.html#ac833828ac975db4c3d05657952c813e5">JoinedOperator</a>.</p>

</div>
</div>
<a id="a80868fb8d8af8ed6b99afe8e0c644707" name="a80868fb8d8af8ed6b99afe8e0c644707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80868fb8d8af8ed6b99afe8e0c644707">&#9670;&nbsp;</a></span>contractL2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::contractL2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_site.html">Site</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_site.html">Site</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dagger</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Contract the operator+ operator with a left term, between bra and ket, and return a new "left" term. If dagger==1, instead of oper+ oper, oper oper+ is calculated. </p>

</div>
</div>
<a id="aeaeca62fcd4e390478bf5755ce868f0a" name="aeaeca62fcd4e390478bf5755ce868f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaeca62fcd4e390478bf5755ce868f0a">&#9670;&nbsp;</a></span>contractMbra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::contractMbra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_site.html">Site</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dagger</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Contract operator with a bra, between left and right terms </p>

<p>Reimplemented in <a class="el" href="class_folded_operator.html#aa64d61e47aee96f556998e42c4b842df">FoldedOperator</a>.</p>

</div>
</div>
<a id="a24ed724a64b3d88446eaa6c2cae47d72" name="a24ed724a64b3d88446eaa6c2cae47d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ed724a64b3d88446eaa6c2cae47d72">&#9670;&nbsp;</a></span>contractMket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::contractMket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_site.html">Site</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dagger</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Contract operator with a ket, between left and right terms </p>

<p>Reimplemented in <a class="el" href="class_folded_operator.html#ac4a5b5467fc627c0b65e6a11ecc17620">FoldedOperator</a>, and <a class="el" href="class_joined_operator.html#a0ff73f659fd0218a015db132f145cf52">JoinedOperator</a>.</p>

</div>
</div>
<a id="a602eda0a198f5c6227ab20b48ef71d0c" name="a602eda0a198f5c6227ab20b48ef71d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602eda0a198f5c6227ab20b48ef71d0c">&#9670;&nbsp;</a></span>contractN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::contractN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dagger</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Contract operator between left and right terms to produce a N matrix </p>

<p>Reimplemented in <a class="el" href="class_folded_operator.html#aa21202794df1fb489d8fe3b9e7ade163">FoldedOperator</a>, and <a class="el" href="class_joined_operator.html#a15d41d69550055d3701bf806228a1bcd">JoinedOperator</a>.</p>

</div>
</div>
<a id="a19923e304de5013934422eb43186ab2f" name="a19923e304de5013934422eb43186ab2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19923e304de5013934422eb43186ab2f">&#9670;&nbsp;</a></span>contractN2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::contractN2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dagger</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Contract the operator+ operator with left and right terms, and return a N matrix. If dagger==1, instead of oper+ oper, oper oper+ is calculated. </p>

</div>
</div>
<a id="a2e75934c3aa9df2c4aeb204b76f46d81" name="a2e75934c3aa9df2c4aeb204b76f46d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e75934c3aa9df2c4aeb204b76f46d81">&#9670;&nbsp;</a></span>contractR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::contractR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_site.html">Site</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_site.html">Site</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dagger</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Contract the operator with a right term, between bra and ket, and return a new "right" term. </p>

<p>Reimplemented in <a class="el" href="class_folded_operator.html#a21feae9e90f38e8ce359ea83dfce2c14">FoldedOperator</a>, and <a class="el" href="class_joined_operator.html#a0cf21726f1801e303aff6d35e157a694">JoinedOperator</a>.</p>

</div>
</div>
<a id="afb58ba7490de349794fd461b7da14269" name="afb58ba7490de349794fd461b7da14269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb58ba7490de349794fd461b7da14269">&#9670;&nbsp;</a></span>contractR2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::contractR2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>termR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_site.html">Site</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_site.html">Site</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dagger</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Contract the operator+ operator with a right term, between bra and ket, and return a new "right" term. </p>

</div>
</div>
<a id="ae4cecb803667ebf7fb9b3df5328a02f6" name="ae4cecb803667ebf7fb9b3df5328a02f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cecb803667ebf7fb9b3df5328a02f6">&#9670;&nbsp;</a></span>contractRight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::contractRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_operator.html">Operator</a> *&#160;</td>
          <td class="paramname"><em>rightOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Contract the right index of data with the left one of rightOp and reshape the result, so that the internal data now is the product of both. </p><dl class="section warning"><dt>Warning</dt><dd>This might change the physical dimensions!! Inherited classes with structure should implement this to keep their properties. </dd></dl>

</div>
</div>
<a id="a9194cd5f6477aa2947aa00c12852db39" name="a9194cd5f6477aa2947aa00c12852db39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9194cd5f6477aa2947aa00c12852db39">&#9670;&nbsp;</a></span>getDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> Operator::getDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return a copy of the dimension vector </p>

</div>
</div>
<a id="a48e19ae5991bb39c2d26b77f65b2d899" name="a48e19ae5991bb39c2d26b77f65b2d899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e19ae5991bb39c2d26b77f65b2d899">&#9670;&nbsp;</a></span>getFullData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classmw_array.html">mwArray</a> Operator::getFullData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return (reference to) the full <a class="el" href="classmw_array.html">mwArray</a> representing this <a class="el" href="class_operator.html">Operator</a>. It has to be implemented by composite operators. </p>

<p>Reimplemented in <a class="el" href="class_folded_operator.html#a2cebd8ec44ceed38c87c41ac12c0d784">FoldedOperator</a>, and <a class="el" href="class_joined_operator.html#a98dcca9b535da94d78f1d971370b791d">JoinedOperator</a>.</p>

</div>
</div>
<a id="aea9d31d7d2b02fa4fb4a26111417cdc1" name="aea9d31d7d2b02fa4fb4a26111417cdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9d31d7d2b02fa4fb4a26111417cdc1">&#9670;&nbsp;</a></span>getInnerDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Operator::getInnerDimension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Let friends obtain a COPY of my internal data </p>

</div>
</div>
<a id="afabb6472bdf16d7deb115599c419adc0" name="afabb6472bdf16d7deb115599c419adc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabb6472bdf16d7deb115599c419adc0">&#9670;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_operator.html">Operator</a> * Operator::identity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return the identity operator for a particular physical dimension </p>

</div>
</div>
<a id="a4a31a00a5252514938238fbe2dfc2039" name="a4a31a00a5252514938238fbe2dfc2039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a31a00a5252514938238fbe2dfc2039">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::put </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Function that actually prints the <a class="el" href="class_operator.html">Operator</a>, and gets overloaded by daughter classes. </p>

<p>Reimplemented in <a class="el" href="class_double_operator.html#a70f86209933b561df00e6f49dc2ec9f7">DoubleOperator</a>, <a class="el" href="class_folded_operator.html#a1e3ad4139c3775ad80e911f89158696b">FoldedOperator</a>, <a class="el" href="class_joined_operator.html#aaa5a119c998a579996c0f20a793c9d97">JoinedOperator</a>, and <a class="el" href="class_variable_operator.html#aa9f2624f50cdc7e45b389dc9dcbf6937">VariableOperator</a>.</p>

</div>
</div>
<a id="a859d7a42ccdc9114331a743ad58eb3d2" name="a859d7a42ccdc9114331a743ad58eb3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859d7a42ccdc9114331a743ad58eb3d2">&#9670;&nbsp;</a></span>savetext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::savetext </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>outfile</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >For exchange with other programs: save to a text file </p>

<p>Reimplemented in <a class="el" href="class_joined_operator.html#a4b472ee58d460bbca96f16b3fe936c96">JoinedOperator</a>.</p>

</div>
</div>
<a id="a97fb2be3fc00cb24b56546e3827ab544" name="a97fb2be3fc00cb24b56546e3827ab544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fb2be3fc00cb24b56546e3827ab544">&#9670;&nbsp;</a></span>setData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::setData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> *&#160;</td>
          <td class="paramname"><em>oper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copy a certain array into the local data, replacing the existing one, if any. If I do not want to copy the array, just store the pointer </p>

</div>
</div>
<a id="a2ba56196a9ee5d496704a19afef90f6b" name="a2ba56196a9ee5d496704a19afef90f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba56196a9ee5d496704a19afef90f6b">&#9670;&nbsp;</a></span>setData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::setData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> *&#160;</td>
          <td class="paramname"><em>oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Dr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >If I do not want to copy the array, just store the pointer. This version is to be used by derived classes, as the former method. </p>

</div>
</div>
<a id="aa110d275c972eb5a8e89c301d5d5a3bc" name="aa110d275c972eb5a8e89c301d5d5a3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa110d275c972eb5a8e89c301d5d5a3bc">&#9670;&nbsp;</a></span>setRotatedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Operator::setRotatedData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>oper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>neworder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjugate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructs a new <a class="el" href="class_operator.html">Operator</a> saving a COPY of the data in oper, but with dimensions permuted as indicated by neworder. If conjugate==true, the data are also complex conjugated. The values of d, d2, Dl and Dr are set according to the newly stored data. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/banulsm/GIT/mpsdyn/src/core/headers/<a class="el" href="_operator_8h_source.html">Operator.h</a></li>
<li>/Users/banulsm/GIT/mpsdyn/src/core/cpp/<a class="el" href="_operator_8cpp.html">Operator.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
