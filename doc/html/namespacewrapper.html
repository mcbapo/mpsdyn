<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mpsdyn: wrapper Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mpsdyn
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">wrapper Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0ae9f9be4532ef9f7bdefd32d065f86a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#a0ae9f9be4532ef9f7bdefd32d065f86a">svd</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, <a class="el" href="classmw_array.html">mwArray</a> &amp;S, <a class="el" href="classmw_array.html">mwArray</a> &amp;Vdagger, bool full=false)</td></tr>
<tr class="separator:a0ae9f9be4532ef9f7bdefd32d065f86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa600aadeec18850b1e33879f851614b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#aa600aadeec18850b1e33879f851614b6">svd</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const double &amp;tol, int &amp;nr, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, <a class="el" href="classmw_array.html">mwArray</a> &amp;S, <a class="el" href="classmw_array.html">mwArray</a> &amp;Vdagger, bool full=false)</td></tr>
<tr class="separator:aa600aadeec18850b1e33879f851614b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f626a7ce0941d057a65118b7ebb2b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#a4f626a7ce0941d057a65118b7ebb2b77">product</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, <a class="el" href="classmw_array.html">mwArray</a> &amp;C)</td></tr>
<tr class="separator:a4f626a7ce0941d057a65118b7ebb2b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccf0c2ce3cb169f6f6fcb858c2a9dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#aeccf0c2ce3cb169f6f6fcb858c2a9dad">eig</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;D, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, bool eigv=0)</td></tr>
<tr class="separator:aeccf0c2ce3cb169f6f6fcb858c2a9dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2243d56e850224b92b984ea6ae3bb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#a0b2243d56e850224b92b984ea6ae3bb1">eigNH</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;Dval, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, bool eigv=0, bool left=0)</td></tr>
<tr class="separator:a0b2243d56e850224b92b984ea6ae3bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671606a77e53e6f4dbabf88302a47215"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#a671606a77e53e6f4dbabf88302a47215">eigs</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const int k, const char *which, std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;D, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, bool eigv=0, double tol=0.)</td></tr>
<tr class="separator:a671606a77e53e6f4dbabf88302a47215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad819a75d2059f3162ba98d84aaa5a55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#aad819a75d2059f3162ba98d84aaa5a55">eigs</a> (<a class="el" href="class_multiplier.html">Multiplier</a> &amp;multi, const int k, const char *which, std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;D, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, bool eigv=0, double tol=0.)</td></tr>
<tr class="separator:aad819a75d2059f3162ba98d84aaa5a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6a9b4563d06259f22347c54a856d78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#ada6a9b4563d06259f22347c54a856d78">lsd</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, <a class="el" href="classmw_array.html">mwArray</a> &amp;<a class="el" href="class_x.html">X</a>, const double &amp;tol=0.)</td></tr>
<tr class="separator:ada6a9b4563d06259f22347c54a856d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6f8ae5845b0995f547775b1f5534d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#a0d6f8ae5845b0995f547775b1f5534d0">lss</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, <a class="el" href="classmw_array.html">mwArray</a> &amp;<a class="el" href="class_x.html">X</a>, const double &amp;tol=0.)</td></tr>
<tr class="separator:a0d6f8ae5845b0995f547775b1f5534d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fe7018134d3a3a0f6507a9b7db0d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#a49fe7018134d3a3a0f6507a9b7db0d9c">lu</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, <a class="el" href="classmw_array.html">mwArray</a> &amp;L, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, <a class="el" href="classmw_array.html">mwArray</a> &amp;P)</td></tr>
<tr class="separator:a49fe7018134d3a3a0f6507a9b7db0d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32be034a7479fd43446c146a2db89a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#ae32be034a7479fd43446c146a2db89a1">lslu</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, <a class="el" href="classmw_array.html">mwArray</a> &amp;<a class="el" href="class_x.html">X</a>)</td></tr>
<tr class="separator:ae32be034a7479fd43446c146a2db89a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76974ed5486db9117a92c0cd7ef562c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#a76974ed5486db9117a92c0cd7ef562c6">lsgsl</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, <a class="el" href="classmw_array.html">mwArray</a> &amp;<a class="el" href="class_x.html">X</a>)</td></tr>
<tr class="separator:a76974ed5486db9117a92c0cd7ef562c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f22d7ab1af23d1c0efd7b100203c4fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#a0f22d7ab1af23d1c0efd7b100203c4fe">qr</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, <a class="el" href="classmw_array.html">mwArray</a> &amp;Q, <a class="el" href="classmw_array.html">mwArray</a> &amp;R)</td></tr>
<tr class="separator:a0f22d7ab1af23d1c0efd7b100203c4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c01827fea418c042bd0f6d6136f6561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#a8c01827fea418c042bd0f6d6136f6561">lq</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, <a class="el" href="classmw_array.html">mwArray</a> &amp;L, <a class="el" href="classmw_array.html">mwArray</a> &amp;Q)</td></tr>
<tr class="separator:a8c01827fea418c042bd0f6d6136f6561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae746ee8605a977a5d4ab2e0489875628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#ae746ee8605a977a5d4ab2e0489875628">expm</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, <a class="el" href="classmw_array.html">mwArray</a> &amp;result, <a class="el" href="structcomplex__t.html">complex_t</a> coeff=ONE_c)</td></tr>
<tr class="separator:ae746ee8605a977a5d4ab2e0489875628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f141f312da5f237cd1a1fcfe13835e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewrapper.html#a98f141f312da5f237cd1a1fcfe13835e">expmTaylor</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, <a class="el" href="classmw_array.html">mwArray</a> &amp;result, int order, <a class="el" href="structcomplex__t.html">complex_t</a> coeff=ONE_c)</td></tr>
<tr class="separator:a98f141f312da5f237cd1a1fcfe13835e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Namespace wrapper hides the direct calls to Lapack, blas and Arpack routines under a more friendly interface. <br  />
 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aeccf0c2ce3cb169f6f6fcb858c2a9dad" name="aeccf0c2ce3cb169f6f6fcb858c2a9dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccf0c2ce3cb169f6f6fcb858c2a9dad">&#9670;&nbsp;</a></span>eig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::eig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eigv</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Full eigenvalue decomposition of matrix A. On exit, D contains the eigenvalues, and, if eigv==true, U contains the eigenvectors, as columns. </p>

</div>
</div>
<a id="a0b2243d56e850224b92b984ea6ae3bb1" name="a0b2243d56e850224b92b984ea6ae3bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2243d56e850224b92b984ea6ae3bb1">&#9670;&nbsp;</a></span>eigNH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::eigNH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eigv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Eigenvalue calculation for general (non-Hermitian) matrices. </p>

</div>
</div>
<a id="a671606a77e53e6f4dbabf88302a47215" name="a671606a77e53e6f4dbabf88302a47215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671606a77e53e6f4dbabf88302a47215">&#9670;&nbsp;</a></span>eigs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wrapper::eigs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eigv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Use iterative method to compute k eigenvalues and eigenvectors of the matrix A. On exit, D contains the eigenvalues, and U contains the corresponding eigenvectors, as columns, if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;eigv&gt;</td><td>was true. </td></tr>
    <tr><td class="paramname">&lt;k&gt;</td><td>decides how many eigenvalues are computed </td></tr>
    <tr><td class="paramname">&lt;which&gt;</td><td>should be a string specifying the criterion: The possible options are "LM": largest magnitude "SM": smallest magnitude "LA": largest real component "SA": smallest real compoent "LI": largest imaginary component "SI": smallest imaginary component If U is not empty, the first column is taken as the initial vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad819a75d2059f3162ba98d84aaa5a55" name="aad819a75d2059f3162ba98d84aaa5a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad819a75d2059f3162ba98d84aaa5a55">&#9670;&nbsp;</a></span>eigs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wrapper::eigs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_multiplier.html">Multiplier</a> &amp;&#160;</td>
          <td class="paramname"><em>multi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eigv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Use iterative method to compute k eigenvalues and eigenvectors of the matrix A. On exit, D contains the eigenvalues, and U contains the corresponding eigenvectors, as columns. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_multiplier.html">Multiplier</a> </dd></dl>

</div>
</div>
<a id="ae746ee8605a977a5d4ab2e0489875628" name="ae746ee8605a977a5d4ab2e0489875628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae746ee8605a977a5d4ab2e0489875628">&#9670;&nbsp;</a></span>expm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::expm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td>
          <td class="paramname"><em>coeff</em> = <code>ONE_c</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the matrix exponential by diagonalizing a full matrix and exponentiating the diagonal of eigenvalues: <img class="formulaInl" alt="$ exp(A) = U exp(D) U^{\dagger}$" src="form_440.png"/>. The matrix should be diagonalizable. The coefficient coeff can contain a factor to put in the exponent. </p>

</div>
</div>
<a id="a98f141f312da5f237cd1a1fcfe13835e" name="a98f141f312da5f237cd1a1fcfe13835e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f141f312da5f237cd1a1fcfe13835e">&#9670;&nbsp;</a></span>expmTaylor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::expmTaylor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td>
          <td class="paramname"><em>coeff</em> = <code>ONE_c</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Exponential of a square matrix, not necessarily diagonalizable, by computing the Taylor series up to a certain order. </p>

</div>
</div>
<a id="a8c01827fea418c042bd0f6d6136f6561" name="a8c01827fea418c042bd0f6d6136f6561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c01827fea418c042bd0f6d6136f6561">&#9670;&nbsp;</a></span>lq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::lq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Contrary to the documentation in Lapack, K is changed after the first call!</p>

</div>
</div>
<a id="ada6a9b4563d06259f22347c54a856d78" name="ada6a9b4563d06259f22347c54a856d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6a9b4563d06259f22347c54a856d78">&#9670;&nbsp;</a></span>lsd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::lsd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve a system of linear equations by a linear least squares routine. A*x=B is solved here using SVD decomposition. If argument tol&gt;0 is specified, it is used as a (relative value!) cutoff to decide on zero singular values of A. </p>

</div>
</div>
<a id="a76974ed5486db9117a92c0cd7ef562c6" name="a76974ed5486db9117a92c0cd7ef562c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76974ed5486db9117a92c0cd7ef562c6">&#9670;&nbsp;</a></span>lsgsl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::lsgsl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve a system of linear equations A*x=B, for a general square matrix A, using the LU decomposition. This version employs the solver from the Gnu Scientific Library. </p>

</div>
</div>
<a id="ae32be034a7479fd43446c146a2db89a1" name="ae32be034a7479fd43446c146a2db89a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32be034a7479fd43446c146a2db89a1">&#9670;&nbsp;</a></span>lslu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::lslu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve a system of linear equations A*x=B, for a general square matrix A, using the LU decomposition. </p>

</div>
</div>
<a id="a0d6f8ae5845b0995f547775b1f5534d0" name="a0d6f8ae5845b0995f547775b1f5534d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6f8ae5845b0995f547775b1f5534d0">&#9670;&nbsp;</a></span>lss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::lss </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve a system of linear equations by a linear least squares routine. A*x=B is solved here using SVD decomposition. If argument tol&gt;0 is specified, it is used as a (relative value!) cutoff to decide on zero singular values of A. Introduced to void crash of zgelsd for large matrices. </p>

</div>
</div>
<a id="a49fe7018134d3a3a0f6507a9b7db0d9c" name="a49fe7018134d3a3a0f6507a9b7db0d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fe7018134d3a3a0f6507a9b7db0d9c">&#9670;&nbsp;</a></span>lu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::lu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the LU decomposition of a given matrix, A. The result is returned in the arguments L (lower triangular with 1 in the diagonal), U (upper triangular) and P (permutation matrix), such that A=P*L*U </p>
<p >But it seems to come as a row of transpostitions=&gt;I transform it to a permutation of indices 1:dimL</p>

</div>
</div>
<a id="a4f626a7ce0941d057a65118b7ebb2b77" name="a4f626a7ce0941d057a65118b7ebb2b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f626a7ce0941d057a65118b7ebb2b77">&#9670;&nbsp;</a></span>product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Product of two matrices, returning the result in C <br  />
 </p>

</div>
</div>
<a id="a0f22d7ab1af23d1c0efd7b100203c4fe" name="a0f22d7ab1af23d1c0efd7b100203c4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f22d7ab1af23d1c0efd7b100203c4fe">&#9670;&nbsp;</a></span>qr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::qr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >QR decomposition of a general matrix A=Q*R If A has dimensions d1 x d2, the function returns a unitary (or isometry) Q of dimensions d1 x min(d1,d2) and an upper triangular (trapezoidal) R min(d1,d2) x d2 </p>
<p >Contrary to the documentation in Lapack, K is changed after the first call!</p>

</div>
</div>
<a id="aa600aadeec18850b1e33879f851614b6" name="aa600aadeec18850b1e33879f851614b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa600aadeec18850b1e33879f851614b6">&#9670;&nbsp;</a></span>svd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::svd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>Vdagger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the singular Value decomposition of matrix A, returns U, S, V+ such that <img class="formulaInl" alt="$A=U\cdot S\cdot V^{\dagger}$" src="form_439.png"/>. Then analyzes how many singular values are bigger than the provided tol, and returns this number in nr. If the original matrix was MxN, the sizes of the returned arrays will be U(Mxnr), S(nrxnr) and V(nrxnr). IMPORTANT: If tol is to be used to cut the small values, set nr to 0. Otherwise, nr values are kept at most. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>Call the lapack routine once before, to assess optimal size! </dd></dl>

</div>
</div>
<a id="a0ae9f9be4532ef9f7bdefd32d065f86a" name="a0ae9f9be4532ef9f7bdefd32d065f86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae9f9be4532ef9f7bdefd32d065f86a">&#9670;&nbsp;</a></span>svd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wrapper::svd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>Vdagger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Singular Value decomposition of matrix A, returns U, S, V+ such that <img class="formulaInl" alt="$A=U\cdot S\cdot V^{\dagger}$" src="form_439.png"/>. If flag full is set to true, full unitaries are returned. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
