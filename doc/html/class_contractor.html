<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mpsdyn: Contractor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mpsdyn
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_contractor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Contractor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_contractor_8h_source.html">Contractor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a836b1237ba3c134ba70dd4a5c2238f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a836b1237ba3c134ba70dd4a5c2238f0a">optimize</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, int D=0, double *errN=0, double *errT=0)</td></tr>
<tr class="separator:a836b1237ba3c134ba70dd4a5c2238f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72db056e97620683aa305877a8c96a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#ad72db056e97620683aa305877a8c96a9">optimizeL</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;bra, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, int D=0, double *errN=0, double *errT=0)</td></tr>
<tr class="separator:ad72db056e97620683aa305877a8c96a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec10e6f148c28717199531e5e59b3ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a0ec10e6f148c28717199531e5e59b3ab">optimizeInv</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, int D=0, double *errN=0, double *errT=0)</td></tr>
<tr class="separator:a0ec10e6f148c28717199531e5e59b3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc248417088c3f2d3c6a1d5cf9315ebc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#afc248417088c3f2d3c6a1d5cf9315ebc">optimizeResolvent</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, double eta, int D=0, double *errN=0, double *errT=0)</td></tr>
<tr class="separator:afc248417088c3f2d3c6a1d5cf9315ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cb715d6d99f6e22c13c72c5170f959"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a13cb715d6d99f6e22c13c72c5170f959">optimizeSum</a> (vector&lt; const <a class="el" href="class_m_p_s.html">MPS</a> * &gt; kets, std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; beta, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, int D=0)</td></tr>
<tr class="separator:a13cb715d6d99f6e22c13c72c5170f959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf67e7f674478a2d4e83718803665fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#adf67e7f674478a2d4e83718803665fb0">optimizeMPS</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, int D=0, double *err=0)</td></tr>
<tr class="separator:adf67e7f674478a2d4e83718803665fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac439d69eccb8f4d33b8f99b1702d54b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#ac439d69eccb8f4d33b8f99b1702d54b4">orthogonalize</a> (<a class="el" href="class_m_p_s.html">MPS</a> &amp;init, int D, const vector&lt; const <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;vectors, const vector&lt; double &gt; &amp;penalties)</td></tr>
<tr class="separator:ac439d69eccb8f4d33b8f99b1702d54b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5b4b655a90cf062d11d84e778cbbf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#abf5b4b655a90cf062d11d84e778cbbf8">orthogonalize</a> (<a class="el" href="class_m_p_s.html">MPS</a> &amp;init, int D, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;orig, const vector&lt; const <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;vectors, const vector&lt; double &gt; &amp;penalties)</td></tr>
<tr class="separator:abf5b4b655a90cf062d11d84e778cbbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0660ef333f4a54b945eeba0efaa6a94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#aa0660ef333f4a54b945eeba0efaa6a94">orthogonalizeSum</a> (<a class="el" href="class_m_p_s.html">MPS</a> &amp;init, int D, const vector&lt; const <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;kets, const vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;beta, const vector&lt; const <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;vectors, const vector&lt; double &gt; &amp;penalties)</td></tr>
<tr class="separator:aa0660ef333f4a54b945eeba0efaa6a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1c7e7f275a9da6a6d18a1489fc835e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a7c1c7e7f275a9da6a6d18a1489fc835e">contract</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;bra, char dir='L')</td></tr>
<tr class="separator:a7c1c7e7f275a9da6a6d18a1489fc835e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4f6622fda66c5e4bedd8320d6a4273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a0c4f6622fda66c5e4bedd8320d6a4273">contract</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;bra, int pos, char dir='L')</td></tr>
<tr class="separator:a0c4f6622fda66c5e4bedd8320d6a4273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91c825fee44cae11c55a564dbb91f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#ae91c825fee44cae11c55a564dbb91f6d">contract</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;bra)</td></tr>
<tr class="separator:ae91c825fee44cae11c55a564dbb91f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1849b49006c2e95f1b047961f218f90c"><td class="memItemLeft" align="right" valign="top"><a id="a1849b49006c2e95f1b047961f218f90c" name="a1849b49006c2e95f1b047961f218f90c"></a>
<a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>contractR</b> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;bra)</td></tr>
<tr class="separator:a1849b49006c2e95f1b047961f218f90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcf2071c64e735000a6cccd5357be36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a7dcf2071c64e735000a6cccd5357be36">contract</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;bra, int pos, char dir='L')</td></tr>
<tr class="separator:a7dcf2071c64e735000a6cccd5357be36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa431ffd564018237e91b998894237580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#aa431ffd564018237e91b998894237580">contract2</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket)</td></tr>
<tr class="separator:aa431ffd564018237e91b998894237580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77053bbcccdd76a84ae0dc1568035a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a77053bbcccdd76a84ae0dc1568035a05">contract2</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;bra, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops)</td></tr>
<tr class="separator:a77053bbcccdd76a84ae0dc1568035a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ba78c8876fc29a5b93fd783f351484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a76ba78c8876fc29a5b93fd783f351484">contract2</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;bra, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket)</td></tr>
<tr class="separator:a76ba78c8876fc29a5b93fd783f351484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd3025e2ad84b47b7821436e476b799"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a5bd3025e2ad84b47b7821436e476b799">setSVDTol</a> (double value)</td></tr>
<tr class="separator:a5bd3025e2ad84b47b7821436e476b799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298ad44e2b47fd5a64fb8a5dc3c652d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a298ad44e2b47fd5a64fb8a5dc3c652d4">setConvTol</a> (double value)</td></tr>
<tr class="separator:a298ad44e2b47fd5a64fb8a5dc3c652d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f93cd511cde0afc9f3c6e0d0a10af6"><td class="memItemLeft" align="right" valign="top"><a id="a23f93cd511cde0afc9f3c6e0d0a10af6" name="a23f93cd511cde0afc9f3c6e0d0a10af6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setExcOrthTol</b> (double value)</td></tr>
<tr class="separator:a23f93cd511cde0afc9f3c6e0d0a10af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae756f9fdd8d894296143211d69418b76"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#ae756f9fdd8d894296143211d69418b76">getConvTol</a> () const</td></tr>
<tr class="separator:ae756f9fdd8d894296143211d69418b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da39a1689df685558eb1a8226d546c3"><td class="memItemLeft" align="right" valign="top"><a id="a5da39a1689df685558eb1a8226d546c3" name="a5da39a1689df685558eb1a8226d546c3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getEigTol</b> () const</td></tr>
<tr class="separator:a5da39a1689df685558eb1a8226d546c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307b8a292b41d6dd3e78fb9f3c33ed49"><td class="memItemLeft" align="right" valign="top"><a id="a307b8a292b41d6dd3e78fb9f3c33ed49" name="a307b8a292b41d6dd3e78fb9f3c33ed49"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getSVDTol</b> () const</td></tr>
<tr class="separator:a307b8a292b41d6dd3e78fb9f3c33ed49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82efc3c7d894751624e2fd929931558e"><td class="memItemLeft" align="right" valign="top"><a id="a82efc3c7d894751624e2fd929931558e" name="a82efc3c7d894751624e2fd929931558e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getExcOrthTol</b> () const</td></tr>
<tr class="separator:a82efc3c7d894751624e2fd929931558e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5413f03ab55c6143a805351cf326e287"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a5413f03ab55c6143a805351cf326e287">setEigTol</a> (double value)</td></tr>
<tr class="separator:a5413f03ab55c6143a805351cf326e287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571255fee8117209381653e2f6add0ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a571255fee8117209381653e2f6add0ed">setEigenSolver</a> (<a class="el" href="_contractor_8h.html#a76798acdd00c42b2a3c1adf41086f551">EigenSolver</a> solver_=arpack)</td></tr>
<tr class="separator:a571255fee8117209381653e2f6add0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91e5dd96e5f2d7ea5e0bf420298a993"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#ac91e5dd96e5f2d7ea5e0bf420298a993">getSolverName</a> () const</td></tr>
<tr class="separator:ac91e5dd96e5f2d7ea5e0bf420298a993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a7eb59d784c637df0ef6f4c0bf75d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#af2a7eb59d784c637df0ef6f4c0bf75d9">findRightEigenvector</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, double *lambda, <a class="el" href="class_m_p_s.html">MPS</a> &amp;resultMPS)</td></tr>
<tr class="separator:af2a7eb59d784c637df0ef6f4c0bf75d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402d9fba839490316cb2ff902496889e"><td class="memItemLeft" align="right" valign="top"><a id="a402d9fba839490316cb2ff902496889e" name="a402d9fba839490316cb2ff902496889e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findLeftEigenvector</b> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, double *lambda, <a class="el" href="class_m_p_s.html">MPS</a> &amp;resultMPS)</td></tr>
<tr class="separator:a402d9fba839490316cb2ff902496889e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a41a88d9bb01fe84319301f4b030e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a91a41a88d9bb01fe84319301f4b030e7">findGroundState</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, double *lambda, <a class="el" href="class_m_p_s.html">MPS</a> &amp;resultMPS, double offset=0., int nrLocalEig=1, const string &amp;tmpfile=&quot;&quot;, int freqSv=200, bool useLM=false)</td></tr>
<tr class="separator:a91a41a88d9bb01fe84319301f4b030e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0d2d9e1e39266df29db3858cd186cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#adb0d2d9e1e39266df29db3858cd186cc">findGroundStateLM</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, double *lambda, <a class="el" href="class_m_p_s.html">MPS</a> &amp;resultMPS, double offset=0., int nrLocalEig=1, const string &amp;tmpfile=&quot;&quot;, int freqSv=200)</td></tr>
<tr class="separator:adb0d2d9e1e39266df29db3858cd186cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb40ac49d29befccf8596658660d091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#acfb40ac49d29befccf8596658660d091">sweepPart</a> (int pos0, int pos1, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, double offset=0., int knr=1)</td></tr>
<tr class="separator:acfb40ac49d29befccf8596658660d091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2345b29f0da55b1b4831593cee060e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a2345b29f0da55b1b4831593cee060e2f">findClosestEigenstate</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, double *lambda, <a class="el" href="class_m_p_s.html">MPS</a> &amp;resultMPS, double target=0., int nrLocalEig=1)</td></tr>
<tr class="separator:a2345b29f0da55b1b4831593cee060e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe42f2814f563dcf970b7c5777b3de6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#abe42f2814f563dcf970b7c5777b3de6f">findNextExcitedState</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;computedLevels, double *lambdak, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, double offset=0., int nrLocalEig=1, const string &amp;tmpfile=&quot;&quot;, int maxTime=0, bool useLM=false)</td></tr>
<tr class="separator:abe42f2814f563dcf970b7c5777b3de6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27da6bf6c6f1809524721386bd7d599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#ac27da6bf6c6f1809524721386bd7d599">findNextExcitedStateLM</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;computedLevels, double *lambdak, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, double offset=0., int nrLocalEig=1, const string &amp;tmpfile=&quot;&quot;, int maxTime=0)</td></tr>
<tr class="separator:ac27da6bf6c6f1809524721386bd7d599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777536ff0ee58c4bfe2930c8bf56e533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a777536ff0ee58c4bfe2930c8bf56e533">findGroundStateWithProjectorPenalty</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, const std::vector&lt; double &gt; &amp;penalties, const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;projected, double *lambdak, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, double offset=0., int nrLocalEig=1, const string &amp;tmpfile=&quot;&quot;, int maxTime=0, bool useLM=false)</td></tr>
<tr class="separator:a777536ff0ee58c4bfe2930c8bf56e533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c919cdd50eed35732419a3aa9573a1c"><td class="memItemLeft" align="right" valign="top"><a id="a9c919cdd50eed35732419a3aa9573a1c" name="a9c919cdd50eed35732419a3aa9573a1c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findGroundStateWithProjectorPenaltyLM</b> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, const std::vector&lt; double &gt; &amp;penalties, const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;projected, double *lambdak, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, double offset=0., int nrLocalEig=1, const string &amp;tmpfile=&quot;&quot;, int maxTime=0)</td></tr>
<tr class="separator:a9c919cdd50eed35732419a3aa9573a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d2f171c941178dc5c97238cb9be994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a35d2f171c941178dc5c97238cb9be994">sweepPartWithProjPenalty</a> (int pos0, int pos1, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, double mu, <a class="el" href="class_m_p_s.html">MPS</a> &amp;projected, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, double offset=0., int nrLocalEig=1)</td></tr>
<tr class="separator:a35d2f171c941178dc5c97238cb9be994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9c6acfee43d3317cc60bcb7c4b92d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#aef9c6acfee43d3317cc60bcb7c4b92d7">sweepPartNextExcitedState</a> (int pos0, int pos1, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;computedLevels, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, double offset=0., int nrLocalEig=1)</td></tr>
<tr class="separator:aef9c6acfee43d3317cc60bcb7c4b92d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edd2b7a330c5e685049907359ef3d56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a4edd2b7a330c5e685049907359ef3d56">sweepPartWithProjectorPenalty</a> (int pos0, int pos1, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, const std::vector&lt; double &gt; &amp;penalties, const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;projected, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, double offset=0., int nrLocalEig=1)</td></tr>
<tr class="separator:a4edd2b7a330c5e685049907359ef3d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fdb1368a450204a56f7137a39e0e0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#aa6fdb1368a450204a56f7137a39e0e0a">findNextClosestEigenstate</a> (const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int D, const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;computedLevels, double *lambdak, <a class="el" href="class_m_p_s.html">MPS</a> &amp;init, double target=0., int nrLocalEig=1)</td></tr>
<tr class="separator:aa6fdb1368a450204a56f7137a39e0e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0b3316beec246614e77333b067c319"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a1d0b3316beec246614e77333b067c319">getEntropy</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;<a class="el" href="structstate.html">state</a>, int len=0)</td></tr>
<tr class="separator:a1d0b3316beec246614e77333b067c319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a29064a80ea2d2fb87ed4be728e290d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a3a29064a80ea2d2fb87ed4be728e290d">getEntropy</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;<a class="el" href="structstate.html">state</a>, int posL, int posR)</td></tr>
<tr class="separator:a3a29064a80ea2d2fb87ed4be728e290d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa0caac02fe9b232399ab00d045b431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#aafa0caac02fe9b232399ab00d045b431">getRDM</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;<a class="el" href="structstate.html">state</a>, int pos)</td></tr>
<tr class="separator:aafa0caac02fe9b232399ab00d045b431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8192541537d62fc3eef159f781ae7d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a8192541537d62fc3eef159f781ae7d1b">getRDM</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;<a class="el" href="structstate.html">state</a>, int posL, int posR)</td></tr>
<tr class="separator:a8192541537d62fc3eef159f781ae7d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f10541c73bda13ef79fe51f4a0dc16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a39f10541c73bda13ef79fe51f4a0dc16">getSchmidtValues</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;<a class="el" href="structstate.html">state</a>, std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;lambdas, int len=0)</td></tr>
<tr class="separator:a39f10541c73bda13ef79fe51f4a0dc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b131a50f39d27f4281715b5d57d2e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a9b131a50f39d27f4281715b5d57d2e04">getEffectiveOperatorSingleSite</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int pos)</td></tr>
<tr class="separator:a9b131a50f39d27f4281715b5d57d2e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5861ec9d408057e2afce3959947d45d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#ac5861ec9d408057e2afce3959947d45d">getEffectiveOperatorMultiSite</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int k, int pos)</td></tr>
<tr class="separator:ac5861ec9d408057e2afce3959947d45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5104d443cdecb0a7fd37cc38fb4887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tensor_multiplier.html">TensorMultiplier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a1a5104d443cdecb0a7fd37cc38fb4887">getEffectiveOperatorMultiplierSingleSite</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int pos)</td></tr>
<tr class="separator:a1a5104d443cdecb0a7fd37cc38fb4887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19648d372de6e210288ba7ed44cb4480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tensor_multiplier.html">TensorMultiplier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a19648d372de6e210288ba7ed44cb4480">getEffectiveOperatorMultiplierMultiSite</a> (const <a class="el" href="class_m_p_s.html">MPS</a> &amp;ket, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, int k, int pos)</td></tr>
<tr class="separator:a19648d372de6e210288ba7ed44cb4480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6607d62499fda4217d8c459b2d5fff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contractor.html#a9f6607d62499fda4217d8c459b2d5fff">minimizeVariance</a> (<a class="el" href="class_m_p_s.html">MPS</a> &amp;init, const int D, const <a class="el" href="class_m_p_o.html">MPO</a> &amp;ops, const double E0, double penH, double *var, const string &amp;tmpfile=&quot;&quot;, int freqSv=200, int stopRound=1E6)</td></tr>
<tr class="separator:a9f6607d62499fda4217d8c459b2d5fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae5a0f7f3ed578c193ea249a5576ce6cc"><td class="memItemLeft" align="right" valign="top"><a id="ae5a0f7f3ed578c193ea249a5576ce6cc" name="ae5a0f7f3ed578c193ea249a5576ce6cc"></a>
static <a class="el" href="class_contractor.html">Contractor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>theContractor</b> ()</td></tr>
<tr class="separator:ae5a0f7f3ed578c193ea249a5576ce6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Fundamental class that organizes the contractions to optimize the <a class="el" href="class_m_p_s.html">MPS</a> that best approximates the effect of applying an operator row onto a given <a class="el" href="class_m_p_s.html">MPS</a>.</p>
<p >This class contains a row of Operators, that is to be applied to an <a class="el" href="class_m_p_s.html">MPS</a>. It could contain a different operator acting on each site. to be contracted between two <a class="el" href="class_m_p_s.html">MPS</a>, to find its ground state (for Hermitian MPOs), dominant eigenvectors, etc.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>I will be more interested in cases where the same operator is applied to several sites. For this, I should extend the class, instead of storing multiple copies of the same operator. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae91c825fee44cae11c55a564dbb91f6d" name="ae91c825fee44cae11c55a564dbb91f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91c825fee44cae11c55a564dbb91f6d">&#9670;&nbsp;</a></span>contract() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex__t.html">complex_t</a> Contractor::contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Contracts two <a class="el" href="class_m_p_s.html">MPS</a> with an <a class="el" href="class_m_p_o.html">MPO</a> in between and returns the product (a complex value). </p>

</div>
</div>
<a id="a7dcf2071c64e735000a6cccd5357be36" name="a7dcf2071c64e735000a6cccd5357be36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcf2071c64e735000a6cccd5357be36">&#9670;&nbsp;</a></span>contract() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmw_array.html">mwArray</a> Contractor::contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dir</em> = <code>'L'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >As in the contraction of two <a class="el" href="class_m_p_s.html">MPS</a>, this version contracts only part of the chain from left (default) or right, until site pos (excluded), and returns a tensor with dimensions D(bra)*Xi*D(ket) </p>

</div>
</div>
<a id="a7c1c7e7f275a9da6a6d18a1489fc835e" name="a7c1c7e7f275a9da6a6d18a1489fc835e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1c7e7f275a9da6a6d18a1489fc835e">&#9670;&nbsp;</a></span>contract() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex__t.html">complex_t</a> Contractor::contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dir</em> = <code>'L'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Contracts two <a class="el" href="class_m_p_s.html">MPS</a> and returns the scalar product (a complex value). Optional argument dir indicates the direction to apply the contraction (from left to right, if 'L', or right to left if 'R'). Both ket and bra are actually to be given as kets, and bra will be appropriately conjugated for the computation. </p>

</div>
</div>
<a id="a0c4f6622fda66c5e4bedd8320d6a4273" name="a0c4f6622fda66c5e4bedd8320d6a4273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4f6622fda66c5e4bedd8320d6a4273">&#9670;&nbsp;</a></span>contract() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmw_array.html">mwArray</a> Contractor::contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>dir</em> = <code>'L'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Same as before, but contract only part of the chain, until site pos (not included in the contraction). It returns a <a class="el" href="classmw_array.html">mwArray</a>, with dimensions DuxDd </p>

</div>
</div>
<a id="aa431ffd564018237e91b998894237580" name="aa431ffd564018237e91b998894237580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa431ffd564018237e91b998894237580">&#9670;&nbsp;</a></span>contract2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex__t.html">complex_t</a> Contractor::contract2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Contracts the <a class="el" href="class_m_p_o.html">MPO</a> acting on the ket with itselt, to get &lt;ket|O+ O|ket&gt;. This is in general more expensive than any other contraction in the program, therefore is to be used just for error calculations, but not in a regular way. </p>

</div>
</div>
<a id="a77053bbcccdd76a84ae0dc1568035a05" name="a77053bbcccdd76a84ae0dc1568035a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77053bbcccdd76a84ae0dc1568035a05">&#9670;&nbsp;</a></span>contract2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex__t.html">complex_t</a> Contractor::contract2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Contracts the <a class="el" href="class_m_p_o.html">MPO</a> acting on the bra to the left with itselt, to get &lt;bra|O O+|bra&gt;. This is in general more expensive than any other contraction in the program, therefore is to be used just for error calculations, but not in a regular way. </p>

</div>
</div>
<a id="a76ba78c8876fc29a5b93fd783f351484" name="a76ba78c8876fc29a5b93fd783f351484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ba78c8876fc29a5b93fd783f351484">&#9670;&nbsp;</a></span>contract2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex__t.html">complex_t</a> Contractor::contract2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Contracts &lt;bra|O+ O|ket&gt;. This is in general more expensive than any other contraction in the program, therefore is to be used just for error calculations, but not in a regular way. </p>

</div>
</div>
<a id="a2345b29f0da55b1b4831593cee060e2f" name="a2345b29f0da55b1b4831593cee060e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2345b29f0da55b1b4831593cee060e2f">&#9670;&nbsp;</a></span>findClosestEigenstate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::findClosestEigenstate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>resultMPS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrLocalEig</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Try to find the eigenstate that is closest to the given target value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;ops&gt;</td><td>(<a class="el" href="class_m_p_o.html">MPO</a>) represents the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> </td></tr>
    <tr><td class="paramname">&lt;D&gt;</td><td>(int) Maximum bond dimension to be used </td></tr>
    <tr><td class="paramname">&lt;lambda&gt;</td><td>(double*) place to store the computed eigenvalue </td></tr>
    <tr><td class="paramname">&lt;resultMPS&gt;</td><td>(<a class="el" href="class_m_p_s.html">MPS</a>&amp;) place to store the computed eigenvector </td></tr>
    <tr><td class="paramname">&lt;target&gt;</td><td>(double) Value around which we want to find eigenpairs (default value 0.) </td></tr>
    <tr><td class="paramname">&lt;nrLocalEig&gt;</td><td>(int) Number of eigenvalues targetted by every local eigenvalue problem, during sweeps (default 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Notice that this method is much slower than the regular \method&lt;findGroundState&gt; or \method&lt;findNectExcitedState&gt;, due to the slow convergence of the underlying routines to find interior (generalized) eigenvalues. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Add support for ARPACK solver! </dd></dl>

</div>
</div>
<a id="a91a41a88d9bb01fe84319301f4b030e7" name="a91a41a88d9bb01fe84319301f4b030e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a41a88d9bb01fe84319301f4b030e7">&#9670;&nbsp;</a></span>findGroundState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::findGroundState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>resultMPS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrLocalEig</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tmpfile</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>freqSv</em> = <code>200</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLM</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the lowest eigenstate by Rayleigh-Ritz variational method: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[
    min \frac{\langle \Psi| H|\Psi \rangle}{\langle \Psi| \Psi \rangle}.
    \]" src="form_7.png"/>
</p>
<p> To be used on an <a class="el" href="class_m_p_o.html">MPO</a> which represents a <a class="el" href="class_hamiltonian.html">Hamiltonian</a>. If nrLocalEig is given andit is not 1, it is the number of eigenvalues targeted by the underlying local optimizations. If tmpfile is given, every greqSv rounds the temporary result is saved </p>

</div>
</div>
<a id="adb0d2d9e1e39266df29db3858cd186cc" name="adb0d2d9e1e39266df29db3858cd186cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0d2d9e1e39266df29db3858cd186cc">&#9670;&nbsp;</a></span>findGroundStateLM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::findGroundStateLM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>resultMPS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrLocalEig</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tmpfile</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>freqSv</em> = <code>200</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >As findGroundState, but at the level of the local eigensolver, use the option for largest magnitude eigenvalue, instead of the smallest, as this seems more stable. To get this working, we need to shift the H, such that the smallest eigenvalue has also the largest magnitude. This can be done by adding a negative offset, but it has to be large enough. Typically, for NN Hamiltonians, the order of the system size should work.</p>
<p >So far, in most cases analyzed, this was not a problem, except for <a class="el" href="class_stochastic_hamiltonian.html">StochasticHamiltonian</a>, so, although in pple it could be the best option in general, I leave it for now as an optional method, with std calls still using the same. </p>

</div>
</div>
<a id="a777536ff0ee58c4bfe2930c8bf56e533" name="a777536ff0ee58c4bfe2930c8bf56e533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777536ff0ee58c4bfe2930c8bf56e533">&#9670;&nbsp;</a></span>findGroundStateWithProjectorPenalty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::findGroundStateWithProjectorPenalty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>penalties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>projected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lambdak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrLocalEig</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tmpfile</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLM</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The basic method to find excited states is to find a ground state of a given <a class="el" href="class_m_p_o.html">MPO</a> plus a list of projectors with their respective penalties. In the case of the excited state, those are minus the energies, but it could be more general. </p>

</div>
</div>
<a id="aa6fdb1368a450204a56f7137a39e0e0a" name="aa6fdb1368a450204a56f7137a39e0e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fdb1368a450204a56f7137a39e0e0a">&#9670;&nbsp;</a></span>findNextClosestEigenstate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::findNextClosestEigenstate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>computedLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lambdak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrLocalEig</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >As \method&lt;findNextExcitedstate&gt; but for the GEVP (H-target)(H-target)x=lambda(H-target)x </p>
<p >real((Hconjugate(U)*den).getElement(0));</p>

</div>
</div>
<a id="abe42f2814f563dcf970b7c5777b3de6f" name="abe42f2814f563dcf970b7c5777b3de6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe42f2814f563dcf970b7c5777b3de6f">&#9670;&nbsp;</a></span>findNextExcitedState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::findNextExcitedState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>computedLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lambdak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrLocalEig</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tmpfile</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLM</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >After determining the GS as <a class="el" href="class_m_p_s.html">MPS</a>, we can look for a first excited state, as the minimum energy of H-Eo|GS&gt;&lt;GS|. This can be repeated, substracting more eigenstates, to find higher excitations. Takes as arguments a vector containing the already computed excited states. </p><dl class="section warning"><dt>Warning</dt><dd>It will not work if the absolute energy of the excited state that is to be computed lies above zero. Thus, if this could be the case, it is advisable to specify an offset, so that the <a class="el" href="class_hamiltonian.html">Hamiltonian</a> handled will be H+offset*1 </dd></dl>

</div>
</div>
<a id="ac27da6bf6c6f1809524721386bd7d599" name="ac27da6bf6c6f1809524721386bd7d599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27da6bf6c6f1809524721386bd7d599">&#9670;&nbsp;</a></span>findNextExcitedStateLM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::findNextExcitedStateLM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>computedLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lambdak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrLocalEig</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tmpfile</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxTime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Same, using the larget magnitude value, instead of SM </p>

</div>
</div>
<a id="af2a7eb59d784c637df0ef6f4c0bf75d9" name="af2a7eb59d784c637df0ef6f4c0bf75d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a7eb59d784c637df0ef6f4c0bf75d9">&#9670;&nbsp;</a></span>findRightEigenvector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::findRightEigenvector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>resultMPS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the best <a class="el" href="class_m_p_s.html">MPS</a> approximation to the dominant right(left) eigenvector of the given operator row, with maximum bond dimension D. The pointer lambda is filled with the (absolute value of) corresponding eigenvalue. The result is returned in resultMPS, whose initial value is used as starting point. </p>

</div>
</div>
<a id="ae756f9fdd8d894296143211d69418b76" name="ae756f9fdd8d894296143211d69418b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae756f9fdd8d894296143211d69418b76">&#9670;&nbsp;</a></span>getConvTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Contractor::getConvTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return the convergence criteria in use </p>

</div>
</div>
<a id="a19648d372de6e210288ba7ed44cb4480" name="a19648d372de6e210288ba7ed44cb4480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19648d372de6e210288ba7ed44cb4480">&#9670;&nbsp;</a></span>getEffectiveOperatorMultiplierMultiSite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tensor_multiplier.html">TensorMultiplier</a> Contractor::getEffectiveOperatorMultiplierMultiSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >As the previous method, but gets the effective operator for k adjacent sites starting on position pos </p>

</div>
</div>
<a id="a1a5104d443cdecb0a7fd37cc38fb4887" name="a1a5104d443cdecb0a7fd37cc38fb4887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5104d443cdecb0a7fd37cc38fb4887">&#9670;&nbsp;</a></span>getEffectiveOperatorMultiplierSingleSite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tensor_multiplier.html">TensorMultiplier</a> Contractor::getEffectiveOperatorMultiplierSingleSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given an <a class="el" href="class_m_p_s.html">MPS</a> and an <a class="el" href="class_m_p_o.html">MPO</a>, return the effective operator for one site as a <a class="el" href="class_tensor_multiplier.html">TensorMultiplier</a> (which can then be used by eigs). The <a class="el" href="class_multiplier.html">Multiplier</a> will consist of the contracted MPS-MPO-MPS to the left and the right, and the local operator term in the center. In general, if the dimensions are large, this will be more convenient than getting the full operator as a <a class="el" href="classmw_array.html">mwArray</a>. </p>

</div>
</div>
<a id="ac5861ec9d408057e2afce3959947d45d" name="ac5861ec9d408057e2afce3959947d45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5861ec9d408057e2afce3959947d45d">&#9670;&nbsp;</a></span>getEffectiveOperatorMultiSite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmw_array.html">mwArray</a> Contractor::getEffectiveOperatorMultiSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >As the previous method, but gets the effective operator for k adjacent sites starting on position pos </p>

</div>
</div>
<a id="a9b131a50f39d27f4281715b5d57d2e04" name="a9b131a50f39d27f4281715b5d57d2e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b131a50f39d27f4281715b5d57d2e04">&#9670;&nbsp;</a></span>getEffectiveOperatorSingleSite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmw_array.html">mwArray</a> Contractor::getEffectiveOperatorSingleSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given an <a class="el" href="class_m_p_s.html">MPS</a> and an <a class="el" href="class_m_p_o.html">MPO</a>, compute the effective operator for one site, by contracting MPS-MPO-MPS to the left and the right, and then contracting with the local operator term. Returns a <a class="el" href="classmw_array.html">mwArray</a> of dimension (d x Dl x Dr )^2, as would be acting on the ket </p>

</div>
</div>
<a id="a1d0b3316beec246614e77333b067c319" name="a1d0b3316beec246614e77333b067c319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0b3316beec246614e77333b067c319">&#9670;&nbsp;</a></span>getEntropy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Contractor::getEntropy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a <a class="el" href="class_m_p_s.html">MPS</a>, calculate the entropy of part of the chain, for the first</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;len&gt;</td><td>sites. If len==0, the entropy of half of the chain is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a29064a80ea2d2fb87ed4be728e290d" name="a3a29064a80ea2d2fb87ed4be728e290d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a29064a80ea2d2fb87ed4be728e290d">&#9670;&nbsp;</a></span>getEntropy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Contractor::getEntropy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given an <a class="el" href="class_m_p_s.html">MPS</a>, compute the entropy of an internal subchain, containing sites from</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;posL&gt;</td><td>to</td></tr>
    <tr><td class="paramname">&lt;posR&gt;,both</td><td>included (sites numbered from 0 to L-1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafa0caac02fe9b232399ab00d045b431" name="aafa0caac02fe9b232399ab00d045b431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa0caac02fe9b232399ab00d045b431">&#9670;&nbsp;</a></span>getRDM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmw_array.html">mwArray</a> Contractor::getRDM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given an <a class="el" href="class_m_p_s.html">MPS</a>, construct the reduced density matrix for site pos (starting from 0) </p>

</div>
</div>
<a id="a8192541537d62fc3eef159f781ae7d1b" name="a8192541537d62fc3eef159f781ae7d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8192541537d62fc3eef159f781ae7d1b">&#9670;&nbsp;</a></span>getRDM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmw_array.html">mwArray</a> Contractor::getRDM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a <a class="el" href="class_m_p_s.html">MPS</a>, construct the RDM for sites posL-posR (both included) </p>

</div>
</div>
<a id="a39f10541c73bda13ef79fe51f4a0dc16" name="a39f10541c73bda13ef79fe51f4a0dc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f10541c73bda13ef79fe51f4a0dc16">&#9670;&nbsp;</a></span>getSchmidtValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::getSchmidtValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambdas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a <a class="el" href="class_m_p_s.html">MPS</a>, calculate the Schmidt values when the chain is cut after the first</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;len&gt;</td><td>sites. If len==0, the middle cut is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac91e5dd96e5f2d7ea5e0bf420298a993" name="ac91e5dd96e5f2d7ea5e0bf420298a993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91e5dd96e5f2d7ea5e0bf420298a993">&#9670;&nbsp;</a></span>getSolverName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string Contractor::getSolverName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the name of the eigensolver in use </p>

</div>
</div>
<a id="a9f6607d62499fda4217d8c459b2d5fff" name="a9f6607d62499fda4217d8c459b2d5fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6607d62499fda4217d8c459b2d5fff">&#9670;&nbsp;</a></span>minimizeVariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::minimizeVariance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>E0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>penH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tmpfile</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>freqSv</em> = <code>200</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stopRound</em> = <code>1E6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Variational miniization of the variance of the given <a class="el" href="class_m_p_o.html">MPO</a>, with a non-quadratic cost function. </p>

</div>
</div>
<a id="a836b1237ba3c134ba70dd4a5c2238f0a" name="a836b1237ba3c134ba70dd4a5c2238f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836b1237ba3c134ba70dd4a5c2238f0a">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::optimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>errN</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>errT</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finds an optimal <a class="el" href="class_m_p_s.html">MPS</a> approximation to the action of the <a class="el" href="class_m_p_o.html">MPO</a> on the original <a class="el" href="class_m_p_s.html">MPS</a> (ket). The bond dimension used will be that of the initial <a class="el" href="class_m_p_s.html">MPS(default, equal to orig)</a>. The result is returned inside init. This could be empty, in which case, a copy of the original ket is used as a starting point (after adjusting dimensions and gauge). If a value D!=0 is given, it is the value used for the maximum bond of the final <a class="el" href="class_m_p_s.html">MPS</a>, provided it is larger or equal than the max bond of orig. If errN!=0 is given, this methods computes also the (unnormalized) truncation error, <img class="formulaInl" alt="$*errN=\| result - Ops ket \|^2$" src="form_4.png"/> If errT!=0 is also given, then it returns errT=norm1=norm(ops ket)^2. WARNING: This is a costly calculation, and should be spared, if possible. </p>
<p >I approximate by an <a class="el" href="class_m_p_s.html">MPS</a> satisfying gauge condition, times a normalization factor. This makes the behaviour more stable and allows a simpler optimization. Moreover, I avoid the calculation of the (expensive) N matrix, as this is guaranteed to be the identity.</p>

</div>
</div>
<a id="a0ec10e6f148c28717199531e5e59b3ab" name="a0ec10e6f148c28717199531e5e59b3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec10e6f148c28717199531e5e59b3ab">&#9670;&nbsp;</a></span>optimizeInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::optimizeInv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>errN</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>errT</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finds an <a class="el" href="class_m_p_s.html">MPS</a> approximation to the action of the inverse of the given <a class="el" href="class_m_p_o.html">MPO</a> on the original <a class="el" href="class_m_p_s.html">MPS</a> (ket). To this end, /f$ | ops |init\rangle - |ket \rangle | /f$ is optimized. The bond dimension used will be that of the initial <a class="el" href="class_m_p_s.html">MPS(default, equal to orig)</a>. <a class="el" href="class_m_p_s.html">MPS</a> init is taken as a starting point for the optimization, and at the end contains the result. If a value D!=0 is given, it is the value used for the maximum bond of the final <a class="el" href="class_m_p_s.html">MPS</a>, provided it is larger or equal than the max bond of orig. If errN!=0 is given, this methods computes also the (unnormalized) truncation error, <img class="formulaInl" alt="$*errN=\| ops result - ket \|^2$" src="form_5.png"/> If errT!=0 is also given, then it returns errT=norm1=norm(ops ket)^2. WARNING: This is a costly calculation, and should be spared, if possible. </p>
<p >Now we have to substitute the solved A, but since I do not trust NA=M solution (numerical errors), if I get a distance larger than before, I do not change the state.</p>

</div>
</div>
<a id="ad72db056e97620683aa305877a8c96a9" name="ad72db056e97620683aa305877a8c96a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72db056e97620683aa305877a8c96a9">&#9670;&nbsp;</a></span>optimizeL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::optimizeL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>errN</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>errT</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find an optimal (bra) <a class="el" href="class_m_p_s.html">MPS</a> approximation to the LEFT action of the <a class="el" href="class_m_p_o.html">MPO</a> on the original (bra) <a class="el" href="class_m_p_s.html">MPS</a>. As before, if no initial <a class="el" href="class_m_p_s.html">MPS</a> is given, a copy of bra is taken as starting point. IMPORTANT: the state bra on which the operator acts has to be given as ket (i.e., it will be conjugated within the method) and the result is also given as a ket (the return value is thus |Psi&gt; s.t. &lt;Psi|~&lt;bra| Ops) If a value D!=0 is given, it is the value used for the maximum bond of the final <a class="el" href="class_m_p_s.html">MPS</a>, provided it is larger or equal than the max bond of orig. If errN!=0 is given, this method computes also the truncation error errN=|bra ops - result|^2 If errT!=0 is also given, then it returns errT=norm1=norm(bra ops)^2. See <a class="el" href="class_contractor.html#a836b1237ba3c134ba70dd4a5c2238f0a">optimize()</a> for details. </p>

</div>
</div>
<a id="adf67e7f674478a2d4e83718803665fb0" name="adf67e7f674478a2d4e83718803665fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf67e7f674478a2d4e83718803665fb0">&#9670;&nbsp;</a></span>optimizeMPS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::optimizeMPS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>err</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A particular case of optimizeSum is the optimization of a single <a class="el" href="class_m_p_s.html">MPS</a> as a <a class="el" href="class_m_p_s.html">MPS</a> of smaller bond dimension. This method is just a simpler interface to the one above, with the option to estimate the error, if the double pointer err is provided. </p>

</div>
</div>
<a id="afc248417088c3f2d3c6a1d5cf9315ebc" name="afc248417088c3f2d3c6a1d5cf9315ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc248417088c3f2d3c6a1d5cf9315ebc">&#9670;&nbsp;</a></span>optimizeResolvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::optimizeResolvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>ket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>errN</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>errT</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >As the former one, but optimizes <a class="el" href="class_m_p_s.html">MPS</a> init such that /f$ | (ops-i \eta )|init \rangle - | ket \rangle | /f$ is minimal. </p>
<p >Now we have to substitute the solved A, but since I do not trust NA=M solution (numerical errors), if I get a distance larger than before, I do not change the state.</p>

</div>
</div>
<a id="a13cb715d6d99f6e22c13c72c5170f959" name="a13cb715d6d99f6e22c13c72c5170f959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cb715d6d99f6e22c13c72c5170f959">&#9670;&nbsp;</a></span>optimizeSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::optimizeSum </td>
          <td>(</td>
          <td class="paramtype">vector&lt; const <a class="el" href="class_m_p_s.html">MPS</a> * &gt;&#160;</td>
          <td class="paramname"><em>kets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Optimize the <a class="el" href="class_m_p_s.html">MPS</a> init such that it is the best <a class="el" href="class_m_p_s.html">MPS</a> approximation (with bond dimension D) to a sum of <a class="el" href="class_m_p_s.html">MPS</a> (in vector kets) with complex coefficients (in vector beta), /f$\sum_k \beta_k|ket_k\rangle /f$ </p>

</div>
</div>
<a id="abf5b4b655a90cf062d11d84e778cbbf8" name="abf5b4b655a90cf062d11d84e778cbbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5b4b655a90cf062d11d84e778cbbf8">&#9670;&nbsp;</a></span>orthogonalize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::orthogonalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>penalties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Similar to \method&lt;orthogonalize&gt;, but the vector to be approximated is the result of an <a class="el" href="class_m_p_o.html">MPO</a> acting on a <a class="el" href="class_m_p_s.html">MPS</a>. </p>
<p >Now we have to substitute the solved A, but I check first that the distance is not increasing (only allowed within numerical precision)</p>

</div>
</div>
<a id="ac439d69eccb8f4d33b8f99b1702d54b4" name="ac439d69eccb8f4d33b8f99b1702d54b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac439d69eccb8f4d33b8f99b1702d54b4">&#9670;&nbsp;</a></span>orthogonalize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::orthogonalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>penalties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Orthogonalize the initial <a class="el" href="class_m_p_s.html">MPS</a> (init, containing the initial vector and chenged afterwards) wrt a list of vectors, by trying to minimize the function </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\||\Psi \rangle -| \Phi_0\rangle \|^2+\sum_i \lambda_i \langle \Psi | v_i \rangle \langle v_i |\Psi \rangle \]" src="form_6.png"/>
</p>
<p> It requires values for the penalty terms associated to each of the vectors in the list. </p>
<p >Now we have to substitute the solved A, but I check first that the distance is not increasing (only allowed within numerical precision)</p>

</div>
</div>
<a id="aa0660ef333f4a54b945eeba0efaa6a94" name="aa0660ef333f4a54b945eeba0efaa6a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0660ef333f4a54b945eeba0efaa6a94">&#9670;&nbsp;</a></span>orthogonalizeSum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::orthogonalizeSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>kets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>penalties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >As \method&lt;optimizeSum&gt;, but at the same time that the distance to a sum of vectors is minimized, a constraint for orthogonality w.r.t. other vectors is enforced by means of penalty terms, in the same way as in \method&lt;orthogonalize&gt;. </p>
<p >Now we have to substitute the solved A, but I check first that the distance is not increasing (only allowed within numerical precision)</p>

</div>
</div>
<a id="a298ad44e2b47fd5a64fb8a5dc3c652d4" name="a298ad44e2b47fd5a64fb8a5dc3c652d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298ad44e2b47fd5a64fb8a5dc3c652d4">&#9670;&nbsp;</a></span>setConvTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::setConvTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set the criterion of convergence (relative variation lower than value) </p>

</div>
</div>
<a id="a571255fee8117209381653e2f6add0ed" name="a571255fee8117209381653e2f6add0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571255fee8117209381653e2f6add0ed">&#9670;&nbsp;</a></span>setEigenSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::setEigenSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_contractor_8h.html#a76798acdd00c42b2a3c1adf41086f551">EigenSolver</a>&#160;</td>
          <td class="paramname"><em>solver_</em> = <code>arpack</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set the eigensolver to be used in findGroundState and findNextExcitedState methods. </p>

</div>
</div>
<a id="a5413f03ab55c6143a805351cf326e287" name="a5413f03ab55c6143a805351cf326e287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5413f03ab55c6143a805351cf326e287">&#9670;&nbsp;</a></span>setEigTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::setEigTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set the tolerance for the eigensolver </p>

</div>
</div>
<a id="a5bd3025e2ad84b47b7821436e476b799" name="a5bd3025e2ad84b47b7821436e476b799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd3025e2ad84b47b7821436e476b799">&#9670;&nbsp;</a></span>setSVDTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::setSVDTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set the cutoff for the inversion of N in the system of equations </p>

</div>
</div>
<a id="acfb40ac49d29befccf8596658660d091" name="acfb40ac49d29befccf8596658660d091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb40ac49d29befccf8596658660d091">&#9670;&nbsp;</a></span>sweepPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::sweepPart </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>knr</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Apply part os a sweep of GS search between sites pos0 and pos1. </p>

</div>
</div>
<a id="aef9c6acfee43d3317cc60bcb7c4b92d7" name="aef9c6acfee43d3317cc60bcb7c4b92d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9c6acfee43d3317cc60bcb7c4b92d7">&#9670;&nbsp;</a></span>sweepPartNextExcitedState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::sweepPartNextExcitedState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>computedLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrLocalEig</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >As \method&lt;sweepPart&gt;, but for the next excited state iteration. </p>

</div>
</div>
<a id="a4edd2b7a330c5e685049907359ef3d56" name="a4edd2b7a330c5e685049907359ef3d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edd2b7a330c5e685049907359ef3d56">&#9670;&nbsp;</a></span>sweepPartWithProjectorPenalty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::sweepPartWithProjectorPenalty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>penalties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_m_p_s.html">MPS</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>projected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrLocalEig</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >As \method&lt;sweepPart&gt;, but including the penalty projector. </p>

</div>
</div>
<a id="a35d2f171c941178dc5c97238cb9be994" name="a35d2f171c941178dc5c97238cb9be994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d2f171c941178dc5c97238cb9be994">&#9670;&nbsp;</a></span>sweepPartWithProjPenalty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contractor::sweepPartWithProjPenalty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_p_o.html">MPO</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>projected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_p_s.html">MPS</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrLocalEig</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >As \method&lt;sweepPart&gt;, but including the penalty projector. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/banulsm/svn_to_port/mpsdyn/mpsdyn/src/core/headers/<a class="el" href="_contractor_8h_source.html">Contractor.h</a></li>
<li>/Users/banulsm/svn_to_port/mpsdyn/mpsdyn/src/core/cpp/<a class="el" href="_contractor_8cpp.html">Contractor.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
