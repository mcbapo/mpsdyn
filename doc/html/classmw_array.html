<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mpsdyn: mwArray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logoMPSDYN.png"/></td>
  <td id="projectalign">
   <div id="projectname">mpsdyn
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmw_array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mwArray Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mw_array_8h_source.html">mwArray.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3088cd65354ea5580dbcdc50ed579a50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a3088cd65354ea5580dbcdc50ed579a50">mwArray</a> ()</td></tr>
<tr class="separator:a3088cd65354ea5580dbcdc50ed579a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad242243baa40b4333847883703f7e59d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ad242243baa40b4333847883703f7e59d">mwArray</a> (<a class="el" href="structcomplex__t.html">complex_t</a> c)</td></tr>
<tr class="separator:ad242243baa40b4333847883703f7e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897346af628ec8259367a9fb2bfa5972"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a897346af628ec8259367a9fb2bfa5972">mwArray</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;dimensions)</td></tr>
<tr class="separator:a897346af628ec8259367a9fb2bfa5972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537051fa239a4c34c9a8a326003e14dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a537051fa239a4c34c9a8a326003e14dc">mwArray</a> (int rank, const int *dimensions)</td></tr>
<tr class="separator:a537051fa239a4c34c9a8a326003e14dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592612c8b34459f296f1c9eff18574ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a592612c8b34459f296f1c9eff18574ac">mwArray</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;dimensions, const double *data, bool real=false)</td></tr>
<tr class="separator:a592612c8b34459f296f1c9eff18574ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e32ac534147c01a2ebebff0b0c9566c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a6e32ac534147c01a2ebebff0b0c9566c">mwArray</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;dimensions, const <a class="el" href="structcomplex__t.html">complex_t</a> *data)</td></tr>
<tr class="separator:a6e32ac534147c01a2ebebff0b0c9566c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ced00b2c0e760aa188bfc5ceaeb75e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a0ced00b2c0e760aa188bfc5ceaeb75e9">mwArray</a> (std::ifstream &amp;data)</td></tr>
<tr class="separator:a0ced00b2c0e760aa188bfc5ceaeb75e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475c24981605276fe63b16b372a99a4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a475c24981605276fe63b16b372a99a4d">mwArray</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;orig)</td></tr>
<tr class="separator:a475c24981605276fe63b16b372a99a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a098ab8d871e59ec5eb77ee712ed0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a44a098ab8d871e59ec5eb77ee712ed0b">mwArray</a> (const std::vector&lt; double &gt; &amp;revals, bool column=true)</td></tr>
<tr class="separator:a44a098ab8d871e59ec5eb77ee712ed0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1e084ae1e07457f3df5ead457c46a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a6a1e084ae1e07457f3df5ead457c46a4">mwArray</a> (const std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;cvals, bool column=true)</td></tr>
<tr class="separator:a6a1e084ae1e07457f3df5ead457c46a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c1ac094b3ff6bac68e19fab7da4f92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ae3c1ac094b3ff6bac68e19fab7da4f92">~mwArray</a> ()</td></tr>
<tr class="separator:ae3c1ac094b3ff6bac68e19fab7da4f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2bea48da43c66254cd2695e838b8b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a5c2bea48da43c66254cd2695e838b8b6">clear</a> ()</td></tr>
<tr class="separator:a5c2bea48da43c66254cd2695e838b8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b0fbaf0963393e1e859ce147bcb11a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#af6b0fbaf0963393e1e859ce147bcb11a">load</a> (std::ifstream &amp;file)</td></tr>
<tr class="separator:af6b0fbaf0963393e1e859ce147bcb11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a91f897132769b218759aed1d0ab85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ad7a91f897132769b218759aed1d0ab85">save</a> (std::ofstream &amp;file) const</td></tr>
<tr class="separator:ad7a91f897132769b218759aed1d0ab85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c408c031f6511dfcbcfc043c304875"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ab0c408c031f6511dfcbcfc043c304875">savetext</a> (std::ofstream &amp;data, bool real=false) const</td></tr>
<tr class="separator:ab0c408c031f6511dfcbcfc043c304875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6d5d5803fe99d0e7fc9979b7d2f8f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ace6d5d5803fe99d0e7fc9979b7d2f8f0">loadtext</a> (std::ifstream &amp;data, bool real=false)</td></tr>
<tr class="separator:ace6d5d5803fe99d0e7fc9979b7d2f8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3b2dad24a967dec596bec9a129221d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a2d3b2dad24a967dec596bec9a129221d">isMatrix</a> () const</td></tr>
<tr class="separator:a2d3b2dad24a967dec596bec9a129221d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb48cb4baf80ba3b0bab79ace6b47c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a1eb48cb4baf80ba3b0bab79ace6b47c1">isSquare</a> () const</td></tr>
<tr class="separator:a1eb48cb4baf80ba3b0bab79ace6b47c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af169339dbe4448b7590b327f1d1aca1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#af169339dbe4448b7590b327f1d1aca1a">isEmpty</a> () const</td></tr>
<tr class="separator:af169339dbe4448b7590b327f1d1aca1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95c3ef809ef05f22fcd18cbcf3ce898"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ac95c3ef809ef05f22fcd18cbcf3ce898">isDiagonal</a> () const</td></tr>
<tr class="separator:ac95c3ef809ef05f22fcd18cbcf3ce898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd3e72368b5a01b122c746cad389016"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#aabd3e72368b5a01b122c746cad389016">isScalar</a> () const</td></tr>
<tr class="separator:aabd3e72368b5a01b122c746cad389016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623e18246aa5cb6f1b3cb4c3dc19b4b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a623e18246aa5cb6f1b3cb4c3dc19b4b6">isVector</a> () const</td></tr>
<tr class="separator:a623e18246aa5cb6f1b3cb4c3dc19b4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03964f67b90a6c9afa1d147a65ea9a13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a03964f67b90a6c9afa1d147a65ea9a13">isHermitian</a> (double tol=0) const</td></tr>
<tr class="separator:a03964f67b90a6c9afa1d147a65ea9a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60b69ffa78e8667c76d87b142eec157"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#af60b69ffa78e8667c76d87b142eec157">isNull</a> (double tol=0) const</td></tr>
<tr class="separator:af60b69ffa78e8667c76d87b142eec157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a713c7c530900795a1fb68f440c4a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ae8a713c7c530900795a1fb68f440c4a8">getMaxElement</a> (<a class="el" href="structcomplex__t.html">complex_t</a> &amp;value, <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;indices) const</td></tr>
<tr class="separator:ae8a713c7c530900795a1fb68f440c4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937b7d03c3d6b025ef8cfecd55c9585b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a937b7d03c3d6b025ef8cfecd55c9585b">setElement</a> (double revalue, double imvalue, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;indices)</td></tr>
<tr class="separator:a937b7d03c3d6b025ef8cfecd55c9585b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7892e9d21eb020ba5bbdc1459423d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#adf7892e9d21eb020ba5bbdc1459423d1">setElement</a> (<a class="el" href="structcomplex__t.html">complex_t</a> value, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;indices)</td></tr>
<tr class="separator:adf7892e9d21eb020ba5bbdc1459423d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada44bff7af0453ad6481dc9c52471b80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ada44bff7af0453ad6481dc9c52471b80">setElement</a> (<a class="el" href="structcomplex__t.html">complex_t</a> value, int linidx)</td></tr>
<tr class="separator:ada44bff7af0453ad6481dc9c52471b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cedf78e623d6f92ae69213516a7d1db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a0cedf78e623d6f92ae69213516a7d1db">setRealData</a> (int nr,...)</td></tr>
<tr class="separator:a0cedf78e623d6f92ae69213516a7d1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec040af2fcc660d6b5a8c6c430ac6e56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#aec040af2fcc660d6b5a8c6c430ac6e56">setImagData</a> (int nr,...)</td></tr>
<tr class="separator:aec040af2fcc660d6b5a8c6c430ac6e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35351ea81a0962b2d1b8e62859a0261d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a35351ea81a0962b2d1b8e62859a0261d">setData</a> (int nr, const <a class="el" href="structcomplex__t.html">complex_t</a> data[])</td></tr>
<tr class="separator:a35351ea81a0962b2d1b8e62859a0261d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f69ca41cfe23c95181f20d70d6dd553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a8f69ca41cfe23c95181f20d70d6dd553">getElement</a> (double &amp;revalue, double &amp;imvalue, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;indices) const</td></tr>
<tr class="separator:a8f69ca41cfe23c95181f20d70d6dd553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecda5a4d4ceb6d2ebebd0df3633643d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#afecda5a4d4ceb6d2ebebd0df3633643d">getElement</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;indices) const</td></tr>
<tr class="separator:afecda5a4d4ceb6d2ebebd0df3633643d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20846d5b8a1c3bc46a3e8c60104ec78f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a20846d5b8a1c3bc46a3e8c60104ec78f">getElement</a> (int linidx) const</td></tr>
<tr class="separator:a20846d5b8a1c3bc46a3e8c60104ec78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd34ff42e20141fef21f3060fc35af0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a0bd34ff42e20141fef21f3060fc35af0">getDimensions</a> (<a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;dimensions) const</td></tr>
<tr class="separator:a0bd34ff42e20141fef21f3060fc35af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d99875bd24464ba7e7f0a0b42597b10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a5d99875bd24464ba7e7f0a0b42597b10">getDimensions</a> () const</td></tr>
<tr class="separator:a5d99875bd24464ba7e7f0a0b42597b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fe5aa5909263655f1436bb9b9124e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a92fe5aa5909263655f1436bb9b9124e2">getRank</a> () const</td></tr>
<tr class="separator:a92fe5aa5909263655f1436bb9b9124e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab229480c9e8affce80e15713e8ec113d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ab229480c9e8affce80e15713e8ec113d">getDimension</a> (int k) const</td></tr>
<tr class="separator:ab229480c9e8affce80e15713e8ec113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75b7f91944755b5b527167edb6e1df0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ab75b7f91944755b5b527167edb6e1df0">getNrComponents</a> () const</td></tr>
<tr class="separator:ab75b7f91944755b5b527167edb6e1df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87c32a4ac12ba565448d76b2d01f515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ad87c32a4ac12ba565448d76b2d01f515">reshape</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;newdims)</td></tr>
<tr class="separator:ad87c32a4ac12ba565448d76b2d01f515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6ecbd32b0e0bda38bd7c7ddadb3cc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a3e6ecbd32b0e0bda38bd7c7ddadb3cc2">permute</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;neworder, bool conj=false)</td></tr>
<tr class="separator:a3e6ecbd32b0e0bda38bd7c7ddadb3cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad64717f729db13115828563997396e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#abad64717f729db13115828563997396e">transpose</a> (bool conj=false)</td></tr>
<tr class="separator:abad64717f729db13115828563997396e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf459f6591c8a817ff5c9173e33c3c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a3bf459f6591c8a817ff5c9173e33c3c1">conjugate</a> ()</td></tr>
<tr class="separator:a3bf459f6591c8a817ff5c9173e33c3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a6513f3575cd8a2c992ce1a6363852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ac4a6513f3575cd8a2c992ce1a6363852">Hconjugate</a> ()</td></tr>
<tr class="separator:ac4a6513f3575cd8a2c992ce1a6363852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ea91b40393685112f5c0c409676469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#aa7ea91b40393685112f5c0c409676469">changeSign</a> ()</td></tr>
<tr class="separator:aa7ea91b40393685112f5c0c409676469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b850bc9bf700e4bf6384bb067ab294c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a2b850bc9bf700e4bf6384bb067ab294c">fillRandom</a> ()</td></tr>
<tr class="separator:a2b850bc9bf700e4bf6384bb067ab294c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc1f5ce3ac61cad8ef4bf0069bdde2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a8dc1f5ce3ac61cad8ef4bf0069bdde2a">fillWithZero</a> ()</td></tr>
<tr class="separator:a8dc1f5ce3ac61cad8ef4bf0069bdde2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b0f173e72ae1d5abb50b32b51f99bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a07b0f173e72ae1d5abb50b32b51f99bd">fillWithOne</a> ()</td></tr>
<tr class="separator:a07b0f173e72ae1d5abb50b32b51f99bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2586452e3f6ba690e2790b49d4fbd588"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a2586452e3f6ba690e2790b49d4fbd588">subArray</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;ind) const</td></tr>
<tr class="separator:a2586452e3f6ba690e2790b49d4fbd588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8d89c65e78f36feb54760f66dfa980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a5e8d89c65e78f36feb54760f66dfa980">resize</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;newdims, double noise=0.)</td></tr>
<tr class="separator:a5e8d89c65e78f36feb54760f66dfa980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eddee07a6040b3d1abb98646318b635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a2eddee07a6040b3d1abb98646318b635">operator=</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;right)</td></tr>
<tr class="separator:a2eddee07a6040b3d1abb98646318b635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1815386edae662da59a3efaedcd28ff6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a1815386edae662da59a3efaedcd28ff6">multiplyRight</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;right)</td></tr>
<tr class="separator:a1815386edae662da59a3efaedcd28ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fae75bf93d71db01e45dda02125dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a84fae75bf93d71db01e45dda02125dd8">multiplyLeft</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;left)</td></tr>
<tr class="separator:a84fae75bf93d71db01e45dda02125dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc54f5397e9b40004270b582e661d0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#afbc54f5397e9b40004270b582e661d0b">trace</a> (double &amp;re, double &amp;im) const</td></tr>
<tr class="separator:afbc54f5397e9b40004270b582e661d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b46e876b5b8926897452f08f575ba94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a1b46e876b5b8926897452f08f575ba94">trace</a> () const</td></tr>
<tr class="separator:a1b46e876b5b8926897452f08f575ba94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ccd4a89b04843f90d722d103c8fae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a44ccd4a89b04843f90d722d103c8fae9">getDiagonal</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;<a class="el" href="classmw_array.html#a497e2b7717bd5264641677f239733cd3">diag</a>) const</td></tr>
<tr class="separator:a44ccd4a89b04843f90d722d103c8fae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883116b135827eb177d66804c90ad869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a883116b135827eb177d66804c90ad869">getDiagonal</a> (std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;<a class="el" href="classmw_array.html#a497e2b7717bd5264641677f239733cd3">diag</a>) const</td></tr>
<tr class="separator:a883116b135827eb177d66804c90ad869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f395134ef733bcfec1a7ef248131a02"><td class="memItemLeft" align="right" valign="top"><a id="a0f395134ef733bcfec1a7ef248131a02" name="a0f395134ef733bcfec1a7ef248131a02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getRealDiagonal</b> (std::vector&lt; double &gt; &amp;<a class="el" href="classmw_array.html#a497e2b7717bd5264641677f239733cd3">diag</a>) const</td></tr>
<tr class="separator:a0f395134ef733bcfec1a7ef248131a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e90faba43a99d84ae4b13bfea74db2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a15e90faba43a99d84ae4b13bfea74db2">contractLeg</a> (int k1, <a class="el" href="classmw_array.html">mwArray</a> &amp;B, int k2)</td></tr>
<tr class="separator:a15e90faba43a99d84ae4b13bfea74db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac513af181476fbb6989e2c11c908a86b"><td class="memItemLeft" align="right" valign="top"><a id="ac513af181476fbb6989e2c11c908a86b" name="ac513af181476fbb6989e2c11c908a86b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>contractLeg</b> (int k1, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, int k2)</td></tr>
<tr class="separator:ac513af181476fbb6989e2c11c908a86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20dd389103b730352985f0b41c3fb14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ad20dd389103b730352985f0b41c3fb14">contractLegs</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;k1, <a class="el" href="classmw_array.html">mwArray</a> &amp;B, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;k2)</td></tr>
<tr class="separator:ad20dd389103b730352985f0b41c3fb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b2b26d08f7b7a6398e9f3c7b8b8ea4"><td class="memItemLeft" align="right" valign="top"><a id="aa4b2b26d08f7b7a6398e9f3c7b8b8ea4" name="aa4b2b26d08f7b7a6398e9f3c7b8b8ea4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>contractLegs</b> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;k1, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;k2)</td></tr>
<tr class="separator:aa4b2b26d08f7b7a6398e9f3c7b8b8ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c99c1ef12d43293bdcd1cbb3a9cd0a"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a80c99c1ef12d43293bdcd1cbb3a9cd0a">getComponents</a> () const</td></tr>
<tr class="separator:a80c99c1ef12d43293bdcd1cbb3a9cd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a511aa37cadf3d922c2066002d87e093e"><td class="memItemLeft" align="right" valign="top"><a id="a511aa37cadf3d922c2066002d87e093e" name="a511aa37cadf3d922c2066002d87e093e"></a>
static const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> =<a class="el" href="classmw_array.html">mwArray</a>()</td></tr>
<tr class="separator:a511aa37cadf3d922c2066002d87e093e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a64152b7cdb119fffaaca4b959f05486f"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a64152b7cdb119fffaaca4b959f05486f">copyComponents</a> () const</td></tr>
<tr class="separator:a64152b7cdb119fffaaca4b959f05486f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6e3e1c927f7cdae8117bf84f47a0cf"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#aff6e3e1c927f7cdae8117bf84f47a0cf">element</a> (int d1,...)</td></tr>
<tr class="separator:aff6e3e1c927f7cdae8117bf84f47a0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4077f4b3dc9f797a6ce3ae982c050a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ac4077f4b3dc9f797a6ce3ae982c050a0">setPointer</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;dims, double *ptr)</td></tr>
<tr class="separator:ac4077f4b3dc9f797a6ce3ae982c050a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9981f571af5ef492a8ce9840022666ee"><td class="memItemLeft" align="right" valign="top"><a id="a9981f571af5ef492a8ce9840022666ee" name="a9981f571af5ef492a8ce9840022666ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isOwned</b> () const</td></tr>
<tr class="separator:a9981f571af5ef492a8ce9840022666ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b35da62b76983fac420d841b3db263"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a64b35da62b76983fac420d841b3db263">checkIndices</a> (const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;elem) const</td></tr>
<tr class="separator:a64b35da62b76983fac420d841b3db263"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a231602f927f5abeae4fb511317664c20"><td class="memItemLeft" align="right" valign="top"><a id="a231602f927f5abeae4fb511317664c20" name="a231602f927f5abeae4fb511317664c20"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>components</b></td></tr>
<tr class="separator:a231602f927f5abeae4fb511317664c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f1cf6a26ba05de99cb1e825f438daa"><td class="memItemLeft" align="right" valign="top"><a id="a89f1cf6a26ba05de99cb1e825f438daa" name="a89f1cf6a26ba05de99cb1e825f438daa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mine</b></td></tr>
<tr class="separator:a89f1cf6a26ba05de99cb1e825f438daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a58a00935c503330f5558888806a78e8c"><td class="memItemLeft" align="right" valign="top"><a id="a58a00935c503330f5558888806a78e8c" name="a58a00935c503330f5558888806a78e8c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Transposer</b></td></tr>
<tr class="separator:a58a00935c503330f5558888806a78e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa02bfcb38ecaa588c22c9ae5dd36a13"><td class="memItemLeft" align="right" valign="top"><a id="aaa02bfcb38ecaa588c22c9ae5dd36a13" name="aaa02bfcb38ecaa588c22c9ae5dd36a13"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Multiplier</b></td></tr>
<tr class="separator:aaa02bfcb38ecaa588c22c9ae5dd36a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a77249e07c63afa6cf55d96942123cb"><td class="memItemLeft" align="right" valign="top"><a id="a9a77249e07c63afa6cf55d96942123cb" name="a9a77249e07c63afa6cf55d96942123cb"></a>
const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>contractLeg</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, int k1, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, int k2)</td></tr>
<tr class="separator:a9a77249e07c63afa6cf55d96942123cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3510998dd54705d259fa85970e6ebe"><td class="memItemLeft" align="right" valign="top"><a id="adf3510998dd54705d259fa85970e6ebe" name="adf3510998dd54705d259fa85970e6ebe"></a>
const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>contractLegs</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;k1, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;k2)</td></tr>
<tr class="separator:adf3510998dd54705d259fa85970e6ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eb1cadd53ef96c2b858cb4fd95c22f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ab9eb1cadd53ef96c2b858cb4fd95c22f">operator==</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;left, const <a class="el" href="classmw_array.html">mwArray</a> &amp;right)</td></tr>
<tr class="separator:ab9eb1cadd53ef96c2b858cb4fd95c22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df30c6afcbcc725407a74a8ec9dd6c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a0df30c6afcbcc725407a74a8ec9dd6c4">operator*</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;left, const <a class="el" href="classmw_array.html">mwArray</a> &amp;right)</td></tr>
<tr class="separator:a0df30c6afcbcc725407a74a8ec9dd6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707907b2c7b60f34dc169e00a543c730"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a707907b2c7b60f34dc169e00a543c730">operator+</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;left, const <a class="el" href="classmw_array.html">mwArray</a> &amp;right)</td></tr>
<tr class="separator:a707907b2c7b60f34dc169e00a543c730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bb1b01decdca04e3a6e16e26736c73"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a42bb1b01decdca04e3a6e16e26736c73">operator-</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;left, const <a class="el" href="classmw_array.html">mwArray</a> &amp;right)</td></tr>
<tr class="separator:a42bb1b01decdca04e3a6e16e26736c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3481f625c2f10ea9baf56b976041f649"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a3481f625c2f10ea9baf56b976041f649">operator*</a> (const double *alpha, const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA)</td></tr>
<tr class="separator:a3481f625c2f10ea9baf56b976041f649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ace44d1b908bf604f1c3e6e5371f42f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a1ace44d1b908bf604f1c3e6e5371f42f">operator*</a> (const <a class="el" href="structcomplex__t.html">complex_t</a> &amp;alpha, const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA)</td></tr>
<tr class="separator:a1ace44d1b908bf604f1c3e6e5371f42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785dc54c2deae7d434e35152b15ef866"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a785dc54c2deae7d434e35152b15ef866">operator*</a> (const double alpha, const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA)</td></tr>
<tr class="separator:a785dc54c2deae7d434e35152b15ef866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291580666b720db60b8f442aaa61a7ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a291580666b720db60b8f442aaa61a7ce">sqrt</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA)</td></tr>
<tr class="separator:a291580666b720db60b8f442aaa61a7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eae8bd199b7daef0b082b5020e1ce6b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a0eae8bd199b7daef0b082b5020e1ce6b">invertDiag</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA, int &amp;nr)</td></tr>
<tr class="separator:a0eae8bd199b7daef0b082b5020e1ce6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cadd48cef5d7d05e9e804ed99d35de9"><td class="memItemLeft" align="right" valign="top"><a id="a8cadd48cef5d7d05e9e804ed99d35de9" name="a8cadd48cef5d7d05e9e804ed99d35de9"></a>
const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invertDiag</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA, int &amp;nr, const double tol)</td></tr>
<tr class="separator:a8cadd48cef5d7d05e9e804ed99d35de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad19a09a3c8c92551992a1b3259cab53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#aad19a09a3c8c92551992a1b3259cab53">realDiag</a> (int nr, const double *values)</td></tr>
<tr class="separator:aad19a09a3c8c92551992a1b3259cab53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dd9badf7eb85e7c912e500e02d70c2"><td class="memItemLeft" align="right" valign="top"><a id="a24dd9badf7eb85e7c912e500e02d70c2" name="a24dd9badf7eb85e7c912e500e02d70c2"></a>
const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>realDiag</b> (int nr, const std::vector&lt; double &gt; &amp;values)</td></tr>
<tr class="separator:a24dd9badf7eb85e7c912e500e02d70c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497e2b7717bd5264641677f239733cd3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a497e2b7717bd5264641677f239733cd3">diag</a> (int nr, const double *values)</td></tr>
<tr class="separator:a497e2b7717bd5264641677f239733cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544ad5f34f767ae571b506b6e9d550fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a544ad5f34f767ae571b506b6e9d550fc">diag</a> (int nr, const <a class="el" href="structcomplex__t.html">complex_t</a> *values)</td></tr>
<tr class="separator:a544ad5f34f767ae571b506b6e9d550fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ae7412500b81ca371d5ea24a941978"><td class="memItemLeft" align="right" valign="top"><a id="ad5ae7412500b81ca371d5ea24a941978" name="ad5ae7412500b81ca371d5ea24a941978"></a>
const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>diag</b> (const std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;values)</td></tr>
<tr class="separator:ad5ae7412500b81ca371d5ea24a941978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada62bc6248dff949dc614779874dd79f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ada62bc6248dff949dc614779874dd79f">diag</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;values)</td></tr>
<tr class="separator:ada62bc6248dff949dc614779874dd79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6610c58787c8f95b7bcead494beaa5c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a6610c58787c8f95b7bcead494beaa5c1">reshape</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;newdims)</td></tr>
<tr class="separator:a6610c58787c8f95b7bcead494beaa5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d787d3638d526c929dfd365cddda74"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#af7d787d3638d526c929dfd365cddda74">resize</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;newdims)</td></tr>
<tr class="separator:af7d787d3638d526c929dfd365cddda74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bd094a3b25c9a3b455ffabd1e4516a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a42bd094a3b25c9a3b455ffabd1e4516a">permute</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;neworder)</td></tr>
<tr class="separator:a42bd094a3b25c9a3b455ffabd1e4516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0292cd58ffedfbbb252a8b016d6fe4f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a0292cd58ffedfbbb252a8b016d6fe4f5">conjugate</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A)</td></tr>
<tr class="separator:a0292cd58ffedfbbb252a8b016d6fe4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f7368753db3128a7de7be75ae728ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a94f7368753db3128a7de7be75ae728ed">Hconjugate</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A)</td></tr>
<tr class="separator:a94f7368753db3128a7de7be75ae728ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be46cad00806c16c984f15dcca7e483"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a7be46cad00806c16c984f15dcca7e483">norm</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A)</td></tr>
<tr class="separator:a7be46cad00806c16c984f15dcca7e483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03e528566bbc24f0ca55a51cf4765c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ac03e528566bbc24f0ca55a51cf4765c5">inverse</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA, int &amp;nr)</td></tr>
<tr class="separator:ac03e528566bbc24f0ca55a51cf4765c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba925eb86e2c1ca3be6d42378ef23f42"><td class="memItemLeft" align="right" valign="top"><a id="aba925eb86e2c1ca3be6d42378ef23f42" name="aba925eb86e2c1ca3be6d42378ef23f42"></a>
const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inverse</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA, int &amp;nr, const double tol)</td></tr>
<tr class="separator:aba925eb86e2c1ca3be6d42378ef23f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0078f7b144ba2babcd6c55f5fdce2bd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a0078f7b144ba2babcd6c55f5fdce2bd0">constructOperatorProduct</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;result, const <a class="el" href="classmw_array.html">mwArray</a> &amp;opA, const <a class="el" href="classmw_array.html">mwArray</a> &amp;opB)</td></tr>
<tr class="separator:a0078f7b144ba2babcd6c55f5fdce2bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f112e075c42a319d9ef52c477d54db"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#ae3f112e075c42a319d9ef52c477d54db">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA)</td></tr>
<tr class="separator:ae3f112e075c42a319d9ef52c477d54db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b08669baad647919d0d4033c727601"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a37b08669baad647919d0d4033c727601">putForMatlab</a> (std::ostream &amp;os, const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA, const char *name)</td></tr>
<tr class="separator:a37b08669baad647919d0d4033c727601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1217916de8405e3f070b741b3e792a6c"><td class="memItemLeft" align="right" valign="top"><a id="a1217916de8405e3f070b741b3e792a6c" name="a1217916de8405e3f070b741b3e792a6c"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>putForMatlab</b> (std::ostream &amp;os, const <a class="el" href="classmw_array.html">mwArray</a> &amp;mwA, const char *name, int precision)</td></tr>
<tr class="separator:a1217916de8405e3f070b741b3e792a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0766a0bde722f1a7a6827ed82c90b50"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#aa0766a0bde722f1a7a6827ed82c90b50">scalarproduct</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B)</td></tr>
<tr class="separator:aa0766a0bde722f1a7a6827ed82c90b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc98a4a83f3fbbe65b2d6d8122a4cddb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#afc98a4a83f3fbbe65b2d6d8122a4cddb">outerproduct</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B)</td></tr>
<tr class="separator:afc98a4a83f3fbbe65b2d6d8122a4cddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6918a069e6ec27c2fa3ebad75fe6cd94"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a6918a069e6ec27c2fa3ebad75fe6cd94">kron</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B)</td></tr>
<tr class="separator:a6918a069e6ec27c2fa3ebad75fe6cd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2433f33e9789c6950fb877e2078a0240"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a2433f33e9789c6950fb877e2078a0240">kron</a> (<a class="el" href="classmw_array.html">mwArray</a> &amp;A, <a class="el" href="classmw_array.html">mwArray</a> &amp;B)</td></tr>
<tr class="separator:a2433f33e9789c6950fb877e2078a0240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32285c55ea1fd174cb0ea7fc3f7993b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmw_array.html">mwArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmw_array.html#a32285c55ea1fd174cb0ea7fc3f7993b6">hadamard</a> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B)</td></tr>
<tr class="separator:a32285c55ea1fd174cb0ea7fc3f7993b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d7c811945c31acb57a3771bcff4af3"><td class="memItemLeft" align="right" valign="top"><a id="a05d7c811945c31acb57a3771bcff4af3" name="a05d7c811945c31acb57a3771bcff4af3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::svd</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const double &amp;tol, int &amp;nr, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, <a class="el" href="classmw_array.html">mwArray</a> &amp;S, <a class="el" href="classmw_array.html">mwArray</a> &amp;Vdagger, bool full)</td></tr>
<tr class="separator:a05d7c811945c31acb57a3771bcff4af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3712535b7c48800db13e52d93c1b4401"><td class="memItemLeft" align="right" valign="top"><a id="a3712535b7c48800db13e52d93c1b4401" name="a3712535b7c48800db13e52d93c1b4401"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::product</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, <a class="el" href="classmw_array.html">mwArray</a> &amp;C)</td></tr>
<tr class="separator:a3712535b7c48800db13e52d93c1b4401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b751d390ea3977fd6d4fcf648e83c5"><td class="memItemLeft" align="right" valign="top"><a id="aa6b751d390ea3977fd6d4fcf648e83c5" name="aa6b751d390ea3977fd6d4fcf648e83c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::eig</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;D, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, bool eigv)</td></tr>
<tr class="separator:aa6b751d390ea3977fd6d4fcf648e83c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165f456427988e2ab8d0e2cf2210d892"><td class="memItemLeft" align="right" valign="top"><a id="a165f456427988e2ab8d0e2cf2210d892" name="a165f456427988e2ab8d0e2cf2210d892"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::eigNH</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;D, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, bool eigv, bool left)</td></tr>
<tr class="separator:a165f456427988e2ab8d0e2cf2210d892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab1c73049758daceec97e3bb2fa09c1"><td class="memItemLeft" align="right" valign="top"><a id="a6ab1c73049758daceec97e3bb2fa09c1" name="a6ab1c73049758daceec97e3bb2fa09c1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::eigs</b> (<a class="el" href="class_multiplier.html">Multiplier</a> &amp;multi, const int k, const char *which, std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;Dval, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, bool eigv, double tol)</td></tr>
<tr class="separator:a6ab1c73049758daceec97e3bb2fa09c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03de8f3842a6c40faed4eb09a056f099"><td class="memItemLeft" align="right" valign="top"><a id="a03de8f3842a6c40faed4eb09a056f099" name="a03de8f3842a6c40faed4eb09a056f099"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::lsd</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, <a class="el" href="classmw_array.html">mwArray</a> &amp;<a class="el" href="class_x.html">X</a>, const double &amp;tol)</td></tr>
<tr class="separator:a03de8f3842a6c40faed4eb09a056f099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40b4345bebfea67d34ab49fab5cdb8d"><td class="memItemLeft" align="right" valign="top"><a id="ab40b4345bebfea67d34ab49fab5cdb8d" name="ab40b4345bebfea67d34ab49fab5cdb8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::lss</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, <a class="el" href="classmw_array.html">mwArray</a> &amp;<a class="el" href="class_x.html">X</a>, const double &amp;tol)</td></tr>
<tr class="separator:ab40b4345bebfea67d34ab49fab5cdb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9770f80f1860765df1475e30e2aa8c45"><td class="memItemLeft" align="right" valign="top"><a id="a9770f80f1860765df1475e30e2aa8c45" name="a9770f80f1860765df1475e30e2aa8c45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::lu</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, <a class="el" href="classmw_array.html">mwArray</a> &amp;L, <a class="el" href="classmw_array.html">mwArray</a> &amp;U, <a class="el" href="classmw_array.html">mwArray</a> &amp;P)</td></tr>
<tr class="separator:a9770f80f1860765df1475e30e2aa8c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f3fbe6989c497b5baabc4edd493581"><td class="memItemLeft" align="right" valign="top"><a id="a07f3fbe6989c497b5baabc4edd493581" name="a07f3fbe6989c497b5baabc4edd493581"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::lslu</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, const <a class="el" href="classmw_array.html">mwArray</a> &amp;B, <a class="el" href="classmw_array.html">mwArray</a> &amp;<a class="el" href="class_x.html">X</a>)</td></tr>
<tr class="separator:a07f3fbe6989c497b5baabc4edd493581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1d31f13c94d205768ae7e2bfca577d"><td class="memItemLeft" align="right" valign="top"><a id="a5d1d31f13c94d205768ae7e2bfca577d" name="a5d1d31f13c94d205768ae7e2bfca577d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::qr</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, <a class="el" href="classmw_array.html">mwArray</a> &amp;Q, <a class="el" href="classmw_array.html">mwArray</a> &amp;R)</td></tr>
<tr class="separator:a5d1d31f13c94d205768ae7e2bfca577d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e46e8ebfc78c7d66df176e4158cfb51"><td class="memItemLeft" align="right" valign="top"><a id="a4e46e8ebfc78c7d66df176e4158cfb51" name="a4e46e8ebfc78c7d66df176e4158cfb51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wrapper::lq</b> (const <a class="el" href="classmw_array.html">mwArray</a> &amp;A, <a class="el" href="classmw_array.html">mwArray</a> &amp;L, <a class="el" href="classmw_array.html">mwArray</a> &amp;Q)</td></tr>
<tr class="separator:a4e46e8ebfc78c7d66df176e4158cfb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This is an intermediate class, providing <a class="el" href="classmw_array.html">mwArray</a> interface (as Matlab) to tensors that contain my numerical data. These tensors are always complex (if data are real, zeros are stored). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3088cd65354ea5580dbcdc50ed579a50" name="a3088cd65354ea5580dbcdc50ed579a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3088cd65354ea5580dbcdc50ed579a50">&#9670;&nbsp;</a></span>mwArray() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::mwArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create an empty array </p>

</div>
</div>
<a id="ad242243baa40b4333847883703f7e59d" name="ad242243baa40b4333847883703f7e59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad242243baa40b4333847883703f7e59d">&#9670;&nbsp;</a></span>mwArray() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::mwArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Particular case: create a single component array </p>

</div>
</div>
<a id="a897346af628ec8259367a9fb2bfa5972" name="a897346af628ec8259367a9fb2bfa5972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897346af628ec8259367a9fb2bfa5972">&#9670;&nbsp;</a></span>mwArray() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::mwArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new tensor with given number of dimensions and corresponding number of (complex) components. Initialized to zero. </p>

</div>
</div>
<a id="a537051fa239a4c34c9a8a326003e14dc" name="a537051fa239a4c34c9a8a326003e14dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537051fa239a4c34c9a8a326003e14dc">&#9670;&nbsp;</a></span>mwArray() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::mwArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The same constructor can receive the dimensions as a simple array of integers </p>

</div>
</div>
<a id="a592612c8b34459f296f1c9eff18574ac" name="a592612c8b34459f296f1c9eff18574ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592612c8b34459f296f1c9eff18574ac">&#9670;&nbsp;</a></span>mwArray() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::mwArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>real</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a new tensor, filling it in with the given buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;dimensions&gt;</td><td>specifies the dimensions of the tensor </td></tr>
    <tr><td class="paramname">&lt;real&gt;</td><td>(default false) should be true if the data buffer contains only the real parts of the elements (complex parts are zero) </td></tr>
    <tr><td class="paramname">&lt;data&gt;</td><td>contains the sequence of element values (if real==false real and imaginary double per element)</td></tr>
  </table>
  </dd>
</dl>
<p>mwArray::mwArray(int rank_,...):rank(rank_),dims(rank_,1),nrcomponents(1){ va_list dimensions; va_start(dimensions,rank_); for(int k=0;k&lt;rank;k++){ dims[k]=va_arg(dimensions,int); cout&lt;&lt;"Read dim["&lt;&lt;k&lt;&lt;"]="&lt;&lt;dims[k]&lt;&lt;endl; nrcomponents=nrcomponents*dims[k]; g } cout&lt;&lt;"Nr components="&lt;&lt;nrcomponents&lt;&lt;", dims="&lt;&lt;dims&lt;&lt;", rank="&lt;&lt;rank&lt;&lt;endl; components=new double[nrcomponents*2]; // complex <a class="el" href="classmw_array.html#a8dc1f5ce3ac61cad8ef4bf0069bdde2a">fillWithZero()</a>; cout&lt;&lt;"Constructed from variable list of input args "&lt;&lt;*this&lt;&lt;endl; } </p>

</div>
</div>
<a id="a6e32ac534147c01a2ebebff0b0c9566c" name="a6e32ac534147c01a2ebebff0b0c9566c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e32ac534147c01a2ebebff0b0c9566c">&#9670;&nbsp;</a></span>mwArray() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::mwArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex__t.html">complex_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a new tensor, filling it in with the given buffer of complex numbers. </p>

</div>
</div>
<a id="a0ced00b2c0e760aa188bfc5ceaeb75e9" name="a0ced00b2c0e760aa188bfc5ceaeb75e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ced00b2c0e760aa188bfc5ceaeb75e9">&#9670;&nbsp;</a></span>mwArray() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::mwArray </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create from a file </p>

</div>
</div>
<a id="a475c24981605276fe63b16b372a99a4d" name="a475c24981605276fe63b16b372a99a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475c24981605276fe63b16b372a99a4d">&#9670;&nbsp;</a></span>mwArray() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::mwArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copy constructor: performs a deep copy of the argument. </p>

</div>
</div>
<a id="a44a098ab8d871e59ec5eb77ee712ed0b" name="a44a098ab8d871e59ec5eb77ee712ed0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a098ab8d871e59ec5eb77ee712ed0b">&#9670;&nbsp;</a></span>mwArray() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::mwArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>revals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>column</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Special case: transform a vector into a <a class="el" href="classmw_array.html">mwArray</a>, with the dimensions of a vector (default is column order). This version takes real components. </p>

</div>
</div>
<a id="a6a1e084ae1e07457f3df5ead457c46a4" name="a6a1e084ae1e07457f3df5ead457c46a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1e084ae1e07457f3df5ead457c46a4">&#9670;&nbsp;</a></span>mwArray() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::mwArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>column</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Same as before, but taking complex components. </p>

</div>
</div>
<a id="ae3c1ac094b3ff6bac68e19fab7da4f92" name="ae3c1ac094b3ff6bac68e19fab7da4f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c1ac094b3ff6bac68e19fab7da4f92">&#9670;&nbsp;</a></span>~mwArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mwArray::~mwArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Standard destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa7ea91b40393685112f5c0c409676469" name="aa7ea91b40393685112f5c0c409676469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ea91b40393685112f5c0c409676469">&#9670;&nbsp;</a></span>changeSign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::changeSign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Change the sign of the current data, avoiding a copy </p>

</div>
</div>
<a id="a64b35da62b76983fac420d841b3db263" name="a64b35da62b76983fac420d841b3db263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b35da62b76983fac420d841b3db263">&#9670;&nbsp;</a></span>checkIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mwArray::checkIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check if a list of indices corresponds to a valid element in the array </p>

</div>
</div>
<a id="a5c2bea48da43c66254cd2695e838b8b6" name="a5c2bea48da43c66254cd2695e838b8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2bea48da43c66254cd2695e838b8b6">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reduce it to empty <a class="el" href="classmw_array.html">mwArray</a> </p>

</div>
</div>
<a id="a3bf459f6591c8a817ff5c9173e33c3c1" name="a3bf459f6591c8a817ff5c9173e33c3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf459f6591c8a817ff5c9173e33c3c1">&#9670;&nbsp;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::conjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Substitute the data by its complex conjugate </p>

</div>
</div>
<a id="a15e90faba43a99d84ae4b13bfea74db2" name="a15e90faba43a99d84ae4b13bfea74db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e90faba43a99d84ae4b13bfea74db2">&#9670;&nbsp;</a></span>contractLeg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::contractLeg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Contract leg nr k1 of this Tensor with leg nr k2 of the * argument B (k1 and k2 starting on 1). If rank of A was m and that of B, n, after returning, the tensor contains the result of the contraction with dimensions in the following order: [d(1)...d(k1-1),d(k1+1)...d(m),p(0)...p(k2-1),p(k2+1)...p(n)], where [d1...d(m)] and [p1...p(n)] where the original dimensions of A and B. So far, no optimization is done regarding the order of the factors in the contraction, to make best use of matrix multiplication. <br  />
 </p>

</div>
</div>
<a id="ad20dd389103b730352985f0b41c3fb14" name="ad20dd389103b730352985f0b41c3fb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20dd389103b730352985f0b41c3fb14">&#9670;&nbsp;</a></span>contractLegs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::contractLegs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>k2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Contract a list of legs </p>

</div>
</div>
<a id="a64152b7cdb119fffaaca4b959f05486f" name="a64152b7cdb119fffaaca4b959f05486f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64152b7cdb119fffaaca4b959f05486f">&#9670;&nbsp;</a></span>copyComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * mwArray::copyComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Gives back a deep copy of the data buffer, without changing the current object. Useful for copy construction and similar. </p>

</div>
</div>
<a id="aff6e3e1c927f7cdae8117bf84f47a0cf" name="aff6e3e1c927f7cdae8117bf84f47a0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6e3e1c927f7cdae8117bf84f47a0cf">&#9670;&nbsp;</a></span>element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * mwArray::element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the address of a given element of the array. Should be called with as many integer arguments as the number of dimensions. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd>Enforce this behavior. <br  />
 </dd></dl>

</div>
</div>
<a id="a2b850bc9bf700e4bf6384bb067ab294c" name="a2b850bc9bf700e4bf6384bb067ab294c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b850bc9bf700e4bf6384bb067ab294c">&#9670;&nbsp;</a></span>fillRandom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::fillRandom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fill in the <a class="el" href="classmw_array.html">mwArray</a> with random values,discarding the previous buffer, if present. </p>

</div>
</div>
<a id="a07b0f173e72ae1d5abb50b32b51f99bd" name="a07b0f173e72ae1d5abb50b32b51f99bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b0f173e72ae1d5abb50b32b51f99bd">&#9670;&nbsp;</a></span>fillWithOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::fillWithOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fill with (real) ones </p>

</div>
</div>
<a id="a8dc1f5ce3ac61cad8ef4bf0069bdde2a" name="a8dc1f5ce3ac61cad8ef4bf0069bdde2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc1f5ce3ac61cad8ef4bf0069bdde2a">&#9670;&nbsp;</a></span>fillWithZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::fillWithZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fill with zeroes </p>

</div>
</div>
<a id="a80c99c1ef12d43293bdcd1cbb3a9cd0a" name="a80c99c1ef12d43293bdcd1cbb3a9cd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c99c1ef12d43293bdcd1cbb3a9cd0a">&#9670;&nbsp;</a></span>getComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double * mwArray::getComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return a pointer to the actual data buffer. It won't work on a const <a class="el" href="classmw_array.html">mwArray</a>&amp;, therefore there is a method to make a copy of the buffer without actually changing it. </p>

</div>
</div>
<a id="a44ccd4a89b04843f90d722d103c8fae9" name="a44ccd4a89b04843f90d722d103c8fae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ccd4a89b04843f90d722d103c8fae9">&#9670;&nbsp;</a></span>getDiagonal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::getDiagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the diagonal, if the tensor is a matrix, in the argument diag </p>

</div>
</div>
<a id="a883116b135827eb177d66804c90ad869" name="a883116b135827eb177d66804c90ad869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883116b135827eb177d66804c90ad869">&#9670;&nbsp;</a></span>getDiagonal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::getDiagonal </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcomplex__t.html">complex_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>diag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Same, returns as a vector </p>

</div>
</div>
<a id="ab229480c9e8affce80e15713e8ec113d" name="ab229480c9e8affce80e15713e8ec113d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab229480c9e8affce80e15713e8ec113d">&#9670;&nbsp;</a></span>getDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mwArray::getDimension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return the value of the k-th dimension of this array (for k in [0...rank]) </p>

</div>
</div>
<a id="a5d99875bd24464ba7e7f0a0b42597b10" name="a5d99875bd24464ba7e7f0a0b42597b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d99875bd24464ba7e7f0a0b42597b10">&#9670;&nbsp;</a></span>getDimensions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> mwArray::getDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return a copy of the dimensions </p>

</div>
</div>
<a id="a0bd34ff42e20141fef21f3060fc35af0" name="a0bd34ff42e20141fef21f3060fc35af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd34ff42e20141fef21f3060fc35af0">&#9670;&nbsp;</a></span>getDimensions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::getDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Fill in the vector with the array dimensions </p>

</div>
</div>
<a id="afecda5a4d4ceb6d2ebebd0df3633643d" name="afecda5a4d4ceb6d2ebebd0df3633643d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afecda5a4d4ceb6d2ebebd0df3633643d">&#9670;&nbsp;</a></span>getElement() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex__t.html">complex_t</a> mwArray::getElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns, in a <a class="el" href="structcomplex__t.html">complex_t</a>, the real and imaginary part of the element corresponding to the given indices. </p>

</div>
</div>
<a id="a8f69ca41cfe23c95181f20d70d6dd553" name="a8f69ca41cfe23c95181f20d70d6dd553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f69ca41cfe23c95181f20d70d6dd553">&#9670;&nbsp;</a></span>getElement() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::getElement </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>revalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>imvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns, in revalue and imvalue, the real and imaginary part of the element corresponding to the given indices. </p>

</div>
</div>
<a id="a20846d5b8a1c3bc46a3e8c60104ec78f" name="a20846d5b8a1c3bc46a3e8c60104ec78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20846d5b8a1c3bc46a3e8c60104ec78f">&#9670;&nbsp;</a></span>getElement() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex__t.html">complex_t</a> mwArray::getElement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linidx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Idem from a position </p>

</div>
</div>
<a id="ae8a713c7c530900795a1fb68f440c4a8" name="ae8a713c7c530900795a1fb68f440c4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a713c7c530900795a1fb68f440c4a8">&#9670;&nbsp;</a></span>getMaxElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::getMaxElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplex__t.html">complex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the largest element (in absolute value) and its position </p>

</div>
</div>
<a id="ab75b7f91944755b5b527167edb6e1df0" name="ab75b7f91944755b5b527167edb6e1df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75b7f91944755b5b527167edb6e1df0">&#9670;&nbsp;</a></span>getNrComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mwArray::getNrComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return the number of components </p>

</div>
</div>
<a id="a92fe5aa5909263655f1436bb9b9124e2" name="a92fe5aa5909263655f1436bb9b9124e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fe5aa5909263655f1436bb9b9124e2">&#9670;&nbsp;</a></span>getRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mwArray::getRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return the number of dimensions </p>

</div>
</div>
<a id="ac4a6513f3575cd8a2c992ce1a6363852" name="ac4a6513f3575cd8a2c992ce1a6363852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a6513f3575cd8a2c992ce1a6363852">&#9670;&nbsp;</a></span>Hconjugate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::Hconjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Substitute the data by its Hermitian conjugate (only for rank two arrays) </p>

</div>
</div>
<a id="ac95c3ef809ef05f22fcd18cbcf3ce898" name="ac95c3ef809ef05f22fcd18cbcf3ce898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95c3ef809ef05f22fcd18cbcf3ce898">&#9670;&nbsp;</a></span>isDiagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mwArray::isDiagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns true iff the array is 2-dimensional and diagonal. </p>

</div>
</div>
<a id="af169339dbe4448b7590b327f1d1aca1a" name="af169339dbe4448b7590b327f1d1aca1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af169339dbe4448b7590b327f1d1aca1a">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mwArray::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns true iff the array is empty. </p>

</div>
</div>
<a id="a03964f67b90a6c9afa1d147a65ea9a13" name="a03964f67b90a6c9afa1d147a65ea9a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03964f67b90a6c9afa1d147a65ea9a13">&#9670;&nbsp;</a></span>isHermitian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mwArray::isHermitian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns true iff the tensor corresponds to an Hermitian matrix (or real scalar), i.e. iff <img class="formulaInl" alt="$\frac{A-A^{\dagger}}{2}=0$" src="form_439.png"/>, according to the syntax of isNull. </p>

</div>
</div>
<a id="a2d3b2dad24a967dec596bec9a129221d" name="a2d3b2dad24a967dec596bec9a129221d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3b2dad24a967dec596bec9a129221d">&#9670;&nbsp;</a></span>isMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mwArray::isMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns true iff the number of dimensions is two. </p>

</div>
</div>
<a id="af60b69ffa78e8667c76d87b142eec157" name="af60b69ffa78e8667c76d87b142eec157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60b69ffa78e8667c76d87b142eec157">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mwArray::isNull </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns true if all elements are zero. If optional argument tol&gt;0 is given, elements smaller than tol in absolute value are considered to be 0. </p>

</div>
</div>
<a id="aabd3e72368b5a01b122c746cad389016" name="aabd3e72368b5a01b122c746cad389016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd3e72368b5a01b122c746cad389016">&#9670;&nbsp;</a></span>isScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mwArray::isScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns true iff the object has only one component. </p>

</div>
</div>
<a id="a1eb48cb4baf80ba3b0bab79ace6b47c1" name="a1eb48cb4baf80ba3b0bab79ace6b47c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb48cb4baf80ba3b0bab79ace6b47c1">&#9670;&nbsp;</a></span>isSquare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mwArray::isSquare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns true iff the number of dimensions is two and they are equal. </p>

</div>
</div>
<a id="a623e18246aa5cb6f1b3cb4c3dc19b4b6" name="a623e18246aa5cb6f1b3cb4c3dc19b4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623e18246aa5cb6f1b3cb4c3dc19b4b6">&#9670;&nbsp;</a></span>isVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mwArray::isVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns true iff the number of dimensions is one, or if it is two and one of them has size 1. </p>

</div>
</div>
<a id="af6b0fbaf0963393e1e859ce147bcb11a" name="af6b0fbaf0963393e1e859ce147bcb11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b0fbaf0963393e1e859ce147bcb11a">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::load </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Load the <a class="el" href="classmw_array.html">mwArray</a> from a binary file. </p>

</div>
</div>
<a id="ace6d5d5803fe99d0e7fc9979b7d2f8f0" name="ace6d5d5803fe99d0e7fc9979b7d2f8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6d5d5803fe99d0e7fc9979b7d2f8f0">&#9670;&nbsp;</a></span>loadtext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::loadtext </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>real</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Load in text mode for exchange with other programs </p>

</div>
</div>
<a id="a84fae75bf93d71db01e45dda02125dd8" name="a84fae75bf93d71db01e45dda02125dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fae75bf93d71db01e45dda02125dd8">&#9670;&nbsp;</a></span>multiplyLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::multiplyLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Replace the data by the result of multiplying with the argument on the left. If the argument has a single component, the current dimensions are kept, irrespective of left having a particular specification of (singleton) dimensions. </p>

</div>
</div>
<a id="a1815386edae662da59a3efaedcd28ff6" name="a1815386edae662da59a3efaedcd28ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1815386edae662da59a3efaedcd28ff6">&#9670;&nbsp;</a></span>multiplyRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::multiplyRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Replace the data by the result of multiplying with the argument on the right. If the argument has a single component, the current dimensions are kept, irrespective of right having a particular specification of (singleton) dimensions. </p>

</div>
</div>
<a id="a2eddee07a6040b3d1abb98646318b635" name="a2eddee07a6040b3d1abb98646318b635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eddee07a6040b3d1abb98646318b635">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmw_array.html">mwArray</a> &amp; mwArray::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assignment operator: performs a deep copy of the rhs </p>

</div>
</div>
<a id="a3e6ecbd32b0e0bda38bd7c7ddadb3cc2" name="a3e6ecbd32b0e0bda38bd7c7ddadb3cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6ecbd32b0e0bda38bd7c7ddadb3cc2">&#9670;&nbsp;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::permute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>neworder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conj</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reorder the dimensions of the matrix, as indicated by neworder. This requires copying the data in the new order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;neworder&gt;</td><td>contains the new order of indices, from 1 to rank. If</td></tr>
    <tr><td class="paramname">&lt;conj&gt;==true,the</td><td>result is conjugated at the same time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd>Check cache usage. Check Ding's Vacancy tracking algorithm to optimize memory usage. <br  />
 </dd></dl>

</div>
</div>
<a id="ad87c32a4ac12ba565448d76b2d01f515" name="ad87c32a4ac12ba565448d76b2d01f515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87c32a4ac12ba565448d76b2d01f515">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>newdims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Redefine the dimensions, keeping the total number of elements constant. It only affects the way of accessing elements, but not the actual data. One negative index can be included in the list of new dimensions, to provide the syntax of [] in Matlab, i.e. that index will have the required dimension to be compatible with the size of the array. </p>

</div>
</div>
<a id="a5e8d89c65e78f36feb54760f66dfa980" name="a5e8d89c65e78f36feb54760f66dfa980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8d89c65e78f36feb54760f66dfa980">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>newdims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>noise</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">  Change the dimensions to the ones in the argument. The vector
</pre><p> must have the same length as the current rank, and individual dimensions are either expanded (padded with zeroes, or with random numbers between 0 and noise) or reduced (first element kept, rest discarded). <br  />
 </p>

</div>
</div>
<a id="ad7a91f897132769b218759aed1d0ab85" name="ad7a91f897132769b218759aed1d0ab85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a91f897132769b218759aed1d0ab85">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::save </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Save the <a class="el" href="classmw_array.html">mwArray</a> to a binary file. </p>

</div>
</div>
<a id="ab0c408c031f6511dfcbcfc043c304875" name="ab0c408c031f6511dfcbcfc043c304875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c408c031f6511dfcbcfc043c304875">&#9670;&nbsp;</a></span>savetext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::savetext </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>real</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Save in text mode for exchange with other programs. <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">real</td><td>should be true if the data are real, so that only one component is saved (but then it must be read with the flag real set to true!) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35351ea81a0962b2d1b8e62859a0261d" name="a35351ea81a0962b2d1b8e62859a0261d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35351ea81a0962b2d1b8e62859a0261d">&#9670;&nbsp;</a></span>setData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::setData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td>
          <td class="paramname"><em>data</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the data from an array of nr complex values saved in COLUMN MAJOR order </p>

</div>
</div>
<a id="adf7892e9d21eb020ba5bbdc1459423d1" name="adf7892e9d21eb020ba5bbdc1459423d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7892e9d21eb020ba5bbdc1459423d1">&#9670;&nbsp;</a></span>setElement() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::setElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used to manually set the value of a single complex component. with indices given by the vector. </p>

</div>
</div>
<a id="ada44bff7af0453ad6481dc9c52471b80" name="ada44bff7af0453ad6481dc9c52471b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada44bff7af0453ad6481dc9c52471b80">&#9670;&nbsp;</a></span>setElement() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::setElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplex__t.html">complex_t</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Idem from the linear index </p>

</div>
</div>
<a id="a937b7d03c3d6b025ef8cfecd55c9585b" name="a937b7d03c3d6b025ef8cfecd55c9585b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937b7d03c3d6b025ef8cfecd55c9585b">&#9670;&nbsp;</a></span>setElement() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::setElement </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>revalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>imvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Used to manually set the value of a single component. (revalue,imvalue) are the real and imaginary parts of the component with indices given by the vector. </p>

</div>
</div>
<a id="aec040af2fcc660d6b5a8c6c430ac6e56" name="aec040af2fcc660d6b5a8c6c430ac6e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec040af2fcc660d6b5a8c6c430ac6e56">&#9670;&nbsp;</a></span>setImagData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::setImagData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the imaginary part of all elements in the array from a list of doubles.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;nr&gt;</td><td>must be exactly the number of components in the array, and this is the number of elements read afterwards from the list of arguments. The list of values are saved COLUMN MAJOR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4077f4b3dc9f797a6ce3ae982c050a0" name="ac4077f4b3dc9f797a6ce3ae982c050a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4077f4b3dc9f797a6ce3ae982c050a0">&#9670;&nbsp;</a></span>setPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::setPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >To be used by things like eigs, which need to set the inner pointer to a given address. </p>

</div>
</div>
<a id="a0cedf78e623d6f92ae69213516a7d1db" name="a0cedf78e623d6f92ae69213516a7d1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cedf78e623d6f92ae69213516a7d1db">&#9670;&nbsp;</a></span>setRealData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::setRealData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the real part of all elements in the array from a list of doubles.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;nr&gt;</td><td>must be exactly the number of components in the array, and this is the number of elements read afterwards from the list of arguments. The list of values are saved COLUMN MAJOR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2586452e3f6ba690e2790b49d4fbd588" name="a2586452e3f6ba690e2790b49d4fbd588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2586452e3f6ba690e2790b49d4fbd588">&#9670;&nbsp;</a></span>subArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> mwArray::subArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>ind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a subarray by fixing some of the indices in the current one. The argument, ind, must have the same length as the number of dimensions of the array. The elements which are &lt;0 mean that dimension is not touched, while any other value fixes the index corresponding to that dimension. A new <a class="el" href="classmw_array.html">mwArray</a> is returned (as copy: could be done more efficiently) with the dimensions of the fixed indices collapsed. <br  />
 </p>

</div>
</div>
<a id="a1b46e876b5b8926897452f08f575ba94" name="a1b46e876b5b8926897452f08f575ba94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b46e876b5b8926897452f08f575ba94">&#9670;&nbsp;</a></span>trace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex__t.html">complex_t</a> mwArray::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the trace in a complex value </p>

</div>
</div>
<a id="afbc54f5397e9b40004270b582e661d0b" name="afbc54f5397e9b40004270b582e661d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc54f5397e9b40004270b582e661d0b">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::trace </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>im</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the trace of the (complex) rank 2 array, if square. </p>

</div>
</div>
<a id="abad64717f729db13115828563997396e" name="abad64717f729db13115828563997396e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad64717f729db13115828563997396e">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mwArray::transpose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conj</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Particular optimized case, for a transposition on a matrix </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0292cd58ffedfbbb252a8b016d6fe4f5" name="a0292cd58ffedfbbb252a8b016d6fe4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0292cd58ffedfbbb252a8b016d6fe4f5">&#9670;&nbsp;</a></span>conjugate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> conjugate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Instead of reshaping in place, we can return a conjugated copy of the array </p>

</div>
</div>
<a id="a0078f7b144ba2babcd6c55f5fdce2bd0" name="a0078f7b144ba2babcd6c55f5fdce2bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0078f7b144ba2babcd6c55f5fdce2bd0">&#9670;&nbsp;</a></span>constructOperatorProduct</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void constructOperatorProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>opB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Utility to get the tensor product of two matrices, of any dimensions. Notice that, if arguments habe dimensions dA1xdA2 and dB1xdB2, the result will be a rank-2 tensor with dimensions (dA1*dB1,dA2*dB2), and simply reshaping (without permutation) will produce the leg ordering (dA1,dB1,dA2,dB2) </p>

</div>
</div>
<a id="ada62bc6248dff949dc614779874dd79f" name="ada62bc6248dff949dc614779874dd79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada62bc6248dff949dc614779874dd79f">&#9670;&nbsp;</a></span>diag <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> diag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Accept also a vector in <a class="el" href="classmw_array.html">mwArray</a> form (only one non-trivial dimension) </p>

</div>
</div>
<a id="a544ad5f34f767ae571b506b6e9d550fc" name="a544ad5f34f767ae571b506b6e9d550fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544ad5f34f767ae571b506b6e9d550fc">&#9670;&nbsp;</a></span>diag <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> diag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex__t.html">complex_t</a> *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct a diagonal matrix of size nrxnr from an array of complex scalars, given as <a class="el" href="structcomplex__t.html">complex_t</a> </p>

</div>
</div>
<a id="a497e2b7717bd5264641677f239733cd3" name="a497e2b7717bd5264641677f239733cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497e2b7717bd5264641677f239733cd3">&#9670;&nbsp;</a></span>diag <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> diag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct a diagonal matrix of size nrxnr from an array of complex scalars, given as pairs re,im </p>

</div>
</div>
<a id="a32285c55ea1fd174cb0ea7fc3f7993b6" name="a32285c55ea1fd174cb0ea7fc3f7993b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32285c55ea1fd174cb0ea7fc3f7993b6">&#9670;&nbsp;</a></span>hadamard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> hadamard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Hadamard product, or element-wise multiplication, of two arrays, which must have identical dimensions </p>

</div>
</div>
<a id="a94f7368753db3128a7de7be75ae728ed" name="a94f7368753db3128a7de7be75ae728ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f7368753db3128a7de7be75ae728ed">&#9670;&nbsp;</a></span>Hconjugate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> Hconjugate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return the Hermitian conjugate of the matrix </p>

</div>
</div>
<a id="ac03e528566bbc24f0ca55a51cf4765c5" name="ac03e528566bbc24f0ca55a51cf4765c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03e528566bbc24f0ca55a51cf4765c5">&#9670;&nbsp;</a></span>inverse</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>mwA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >(Pseudo-)Invert a square matrix by diagonalizing and inverting the eigenvalues above the specified tolerance. <br  />
 </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>Improve, using zgtref, zgetri </dd></dl>

</div>
</div>
<a id="a0eae8bd199b7daef0b082b5020e1ce6b" name="a0eae8bd199b7daef0b082b5020e1ce6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eae8bd199b7daef0b082b5020e1ce6b">&#9670;&nbsp;</a></span>invertDiag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> invertDiag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>mwA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Invert a square diagonal matrix by inverting the diagonal elements one by one. If a tolerance is specified, the elements such that <img class="formulaInl" alt="$z/trace(A)&lt;tol$" src="form_440.png"/> are treated as zero, and the pseudoinverse is computed. </p>

</div>
</div>
<a id="a6918a069e6ec27c2fa3ebad75fe6cd94" name="a6918a069e6ec27c2fa3ebad75fe6cd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6918a069e6ec27c2fa3ebad75fe6cd94">&#9670;&nbsp;</a></span>kron <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> kron </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Computes the tensor product of two matrices, of dimensions (da1,da2) and (db1,db2), to give a result (da1*db1,da2*db2). </p>

</div>
</div>
<a id="a2433f33e9789c6950fb877e2078a0240" name="a2433f33e9789c6950fb877e2078a0240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2433f33e9789c6950fb877e2078a0240">&#9670;&nbsp;</a></span>kron <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> kron </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A more efficient version: allows for reshape of the matrices </p>

</div>
</div>
<a id="a7be46cad00806c16c984f15dcca7e483" name="a7be46cad00806c16c984f15dcca7e483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be46cad00806c16c984f15dcca7e483">&#9670;&nbsp;</a></span>norm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Supported only for vectors and scalars: returns the absolute value or the Euclidean norm, respectively. TODO: implement for matrices </p>

</div>
</div>
<a id="a1ace44d1b908bf604f1c3e6e5371f42f" name="a1ace44d1b908bf604f1c3e6e5371f42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ace44d1b908bf604f1c3e6e5371f42f">&#9670;&nbsp;</a></span>operator* <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcomplex__t.html">complex_t</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>mwA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Multiplication by a (complex) scalar. Includes the real and purely imaginary cases. </p>

</div>
</div>
<a id="a3481f625c2f10ea9baf56b976041f649" name="a3481f625c2f10ea9baf56b976041f649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3481f625c2f10ea9baf56b976041f649">&#9670;&nbsp;</a></span>operator* <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>mwA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Multiplication by a (complex) scalar. I assume that it comes as an array with two components, real and imaginary parts. </p>

</div>
</div>
<a id="a785dc54c2deae7d434e35152b15ef866" name="a785dc54c2deae7d434e35152b15ef866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785dc54c2deae7d434e35152b15ef866">&#9670;&nbsp;</a></span>operator* <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>mwA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Multiplication by a real scalar. </p>

</div>
</div>
<a id="a0df30c6afcbcc725407a74a8ec9dd6c4" name="a0df30c6afcbcc725407a74a8ec9dd6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df30c6afcbcc725407a74a8ec9dd6c4">&#9670;&nbsp;</a></span>operator* <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Product operator, contracting last dimension of argument left with first dimension of argument right. <br  />
 </p>

</div>
</div>
<a id="a707907b2c7b60f34dc169e00a543c730" name="a707907b2c7b60f34dc169e00a543c730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707907b2c7b60f34dc169e00a543c730">&#9670;&nbsp;</a></span>operator+</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Addition operator </p>

</div>
</div>
<a id="a42bb1b01decdca04e3a6e16e26736c73" name="a42bb1b01decdca04e3a6e16e26736c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bb1b01decdca04e3a6e16e26736c73">&#9670;&nbsp;</a></span>operator-</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Substraction operator </p>

</div>
</div>
<a id="ae3f112e075c42a319d9ef52c477d54db" name="ae3f112e075c42a319d9ef52c477d54db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f112e075c42a319d9ef52c477d54db">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>mwA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="class_operator.html">Operator</a> to print some information about a <a class="el" href="classmw_array.html">mwArray</a>. Mainly intended for debugging purposes, may or may not write the whole content of the buffer. </p>

</div>
</div>
<a id="ab9eb1cadd53ef96c2b858cb4fd95c22f" name="ab9eb1cadd53ef96c2b858cb4fd95c22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9eb1cadd53ef96c2b858cb4fd95c22f">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Comparison operator. Returns true iff arguments are identical, elementwise. </p>

</div>
</div>
<a id="afc98a4a83f3fbbe65b2d6d8122a4cddb" name="afc98a4a83f3fbbe65b2d6d8122a4cddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc98a4a83f3fbbe65b2d6d8122a4cddb">&#9670;&nbsp;</a></span>outerproduct</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> outerproduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Computes the outer product of two vectors, to produce the matrix <img class="formulaInl" alt="$A \cdot B^T $" src="form_442.png"/>, of dimensions dimA x dimB. </p>

</div>
</div>
<a id="a42bd094a3b25c9a3b455ffabd1e4516a" name="a42bd094a3b25c9a3b455ffabd1e4516a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bd094a3b25c9a3b455ffabd1e4516a">&#9670;&nbsp;</a></span>permute</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> permute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>neworder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Instead of reshaping in place, we can return a permuted copy of the array </p>

</div>
</div>
<a id="a37b08669baad647919d0d4033c727601" name="a37b08669baad647919d0d4033c727601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b08669baad647919d0d4033c727601">&#9670;&nbsp;</a></span>putForMatlab</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; putForMatlab </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>mwA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Idem, for Matlab friendly output, as we would input data in Matlab GUI, using name as the name of the array </p>

</div>
</div>
<a id="aad19a09a3c8c92551992a1b3259cab53" name="aad19a09a3c8c92551992a1b3259cab53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad19a09a3c8c92551992a1b3259cab53">&#9670;&nbsp;</a></span>realDiag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> realDiag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct a real diagonal matrix of dimensions nrxnr from an array of scalars</p>
<p >Useful global functions </p>

</div>
</div>
<a id="a6610c58787c8f95b7bcead494beaa5c1" name="a6610c58787c8f95b7bcead494beaa5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6610c58787c8f95b7bcead494beaa5c1">&#9670;&nbsp;</a></span>reshape</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>newdims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Instead of reshaping in place, we can return a reshaped copy of the array </p>

</div>
</div>
<a id="af7d787d3638d526c929dfd365cddda74" name="af7d787d3638d526c929dfd365cddda74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d787d3638d526c929dfd365cddda74">&#9670;&nbsp;</a></span>resize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classshrt_1_1_indices.html">shrt::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>newdims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Instead of resizing in place, we can return a resized copy of the array </p>

</div>
</div>
<a id="aa0766a0bde722f1a7a6827ed82c90b50" name="aa0766a0bde722f1a7a6827ed82c90b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0766a0bde722f1a7a6827ed82c90b50">&#9670;&nbsp;</a></span>scalarproduct</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcomplex__t.html">complex_t</a> scalarproduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Given two vectors, take the scalar product and return a scalar (in this case, as a complex). This method ignores the order in which the dimensions of each of the vectors are specified, and always contracts the long dimension. To compute something like <img class="formulaInl" alt="$v \cdot v^T $" src="form_441.png"/> giving a matrix, use outerproduct. </p>

</div>
</div>
<a id="a291580666b720db60b8f442aaa61a7ce" name="a291580666b720db60b8f442aaa61a7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291580666b720db60b8f442aaa61a7ce">&#9670;&nbsp;</a></span>sqrt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmw_array.html">mwArray</a> sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmw_array.html">mwArray</a> &amp;&#160;</td>
          <td class="paramname"><em>mwA</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Elementwise square root of complex elements. </p><dl class="section warning"><dt>Warning</dt><dd>{Multivalued result not taken into account. Trivial choice of phase} </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/banulsm/GIT/mpsdyn/src/wrapper/<a class="el" href="mw_array_8h_source.html">mwArray.h</a></li>
<li>/Users/banulsm/GIT/mpsdyn/src/wrapper/mwArray.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
